["^ ","~:output",["^ ","~:js","goog.provide('promesa.core');\n/**\n * Return a resolved promise with provided value.\n */\npromesa.core.resolved = (function promesa$core$resolved(v){\nreturn promesa.impl.resolved(v);\n});\n/**\n * Return a rejected promise with provided reason.\n */\npromesa.core.rejected = (function promesa$core$rejected(v){\nreturn promesa.impl.rejected(v);\n});\n/**\n * Creates an empty promise instance.\n */\npromesa.core.deferred = (function promesa$core$deferred(){\nreturn promesa.impl.deferred();\n});\n/**\n * The coerce based promise constructor. Creates a appropriate promise\n *   instance depending on the provided value.\n * \n *   If an executor is provided, it will be used to resolve this\n *   promise.\n */\npromesa.core.promise = (function promesa$core$promise(var_args){\nvar G__25366 = arguments.length;\nswitch (G__25366) {\ncase 1:\nreturn promesa.core.promise.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn promesa.core.promise.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\n(promesa.core.promise.cljs$core$IFn$_invoke$arity$1 = (function (v){\nreturn promesa.protocols._promise(v);\n}));\n\n(promesa.core.promise.cljs$core$IFn$_invoke$arity$2 = (function (v,executor){\nreturn promesa.protocols._map(promesa.protocols._promise(v),cljs.core.identity,executor);\n}));\n\n(promesa.core.promise.cljs$lang$maxFixedArity = 2);\n\n/**\n * A convenience alias for `promise` coercion function that only accepts\n *   a single argument.\n */\npromesa.core.wrap = (function promesa$core$wrap(v){\nreturn promesa.protocols._promise(v);\n});\n/**\n * Create a promise instance from a factory function. If an executor is\n *   provided, the factory will be executed in the provided executor.\n * \n *   A factory function looks like `(fn [resolve reject] (resolve 1))`.\n */\npromesa.core.create = (function promesa$core$create(var_args){\nvar G__25372 = arguments.length;\nswitch (G__25372) {\ncase 1:\nreturn promesa.core.create.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn promesa.core.create.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\n(promesa.core.create.cljs$core$IFn$_invoke$arity$1 = (function (f){\nvar d = promesa.impl.deferred();\ntry{var G__25374_25454 = (function (p1__25367_SHARP_){\nreturn promesa.protocols._resolve_BANG_(d,p1__25367_SHARP_);\n});\nvar G__25375_25455 = (function (p1__25368_SHARP_){\nreturn promesa.protocols._reject_BANG_(d,p1__25368_SHARP_);\n});\n(f.cljs$core$IFn$_invoke$arity$2 ? f.cljs$core$IFn$_invoke$arity$2(G__25374_25454,G__25375_25455) : f.call(null,G__25374_25454,G__25375_25455));\n}catch (e25373){var e_25456 = e25373;\npromesa.protocols._reject_BANG_(d,e_25456);\n}\nreturn d;\n}));\n\n(promesa.core.create.cljs$core$IFn$_invoke$arity$2 = (function (f,executor){\nvar d = promesa.impl.deferred();\npromesa.exec.run_BANG_.cljs$core$IFn$_invoke$arity$2(executor,(function (){\ntry{var G__25377 = (function (p1__25369_SHARP_){\nreturn promesa.protocols._resolve_BANG_(d,p1__25369_SHARP_);\n});\nvar G__25378 = (function (p1__25370_SHARP_){\nreturn promesa.protocols._reject_BANG_(d,p1__25370_SHARP_);\n});\nreturn (f.cljs$core$IFn$_invoke$arity$2 ? f.cljs$core$IFn$_invoke$arity$2(G__25377,G__25378) : f.call(null,G__25377,G__25378));\n}catch (e25376){var e = e25376;\nreturn promesa.protocols._reject_BANG_(d,e);\n}}));\n\nreturn d;\n}));\n\n(promesa.core.create.cljs$lang$maxFixedArity = 2);\n\n/**\n * Return true if `v` is a promise instance.\n */\npromesa.core.promise_QMARK_ = (function promesa$core$promise_QMARK_(v){\nif((!((v == null)))){\nif(((false) || ((cljs.core.PROTOCOL_SENTINEL === v.promesa$protocols$IPromise$)))){\nreturn true;\n} else {\nif((!v.cljs$lang$protocol_mask$partition$)){\nreturn cljs.core.native_satisfies_QMARK_(promesa.protocols.IPromise,v);\n} else {\nreturn false;\n}\n}\n} else {\nreturn cljs.core.native_satisfies_QMARK_(promesa.protocols.IPromise,v);\n}\n});\n/**\n * Return true if `v` is a promise instance (alias to `promise?`).\n */\npromesa.core.deferred_QMARK_ = (function promesa$core$deferred_QMARK_(v){\nreturn (v instanceof promesa.impl._STAR_default_promise_STAR_);\n});\n/**\n * Returns true if `v` is a promise like object.\n */\npromesa.core.thenable_QMARK_ = (function promesa$core$thenable_QMARK_(v){\nreturn ((cljs.core.object_QMARK_(v)) && (cljs.core.fn_QMARK_((v[\"then\"]))));\n});\n/**\n * Returns true if promise `p` is already fulfilled.\n */\npromesa.core.resolved_QMARK_ = (function promesa$core$resolved_QMARK_(p){\nreturn promesa.protocols._resolved_QMARK_(p);\n});\n/**\n * Returns true if promise `p` is already rejected.\n */\npromesa.core.rejected_QMARK_ = (function promesa$core$rejected_QMARK_(p){\nreturn promesa.protocols._rejected_QMARK_(p);\n});\n/**\n * Returns true if promise `p` is stil pending.\n */\npromesa.core.pending_QMARK_ = (function promesa$core$pending_QMARK_(p){\nreturn promesa.protocols._pending_QMARK_(p);\n});\n/**\n * Returns the current promise value.\n */\npromesa.core.extract = (function promesa$core$extract(p){\nreturn promesa.protocols._extract(p);\n});\n/**\n * Returns true if promise `p` is already done.\n */\npromesa.core.done_QMARK_ = cljs.core.complement(promesa.core.pending_QMARK_);\n/**\n * Chains a computation `f` (function) to be executed when the promise\n *   `p` is successfully resolved.\n * \n *   The computation will be executed in the calling thread by default;\n *   you also can provide a custom executor.\n * \n *   If the function `f` returns a promise instance, it will be\n *   automatically unwrapped.\n */\npromesa.core.then = (function promesa$core$then(var_args){\nvar G__25381 = arguments.length;\nswitch (G__25381) {\ncase 2:\nreturn promesa.core.then.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn promesa.core.then.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\n(promesa.core.then.cljs$core$IFn$_invoke$arity$2 = (function (p,f){\nreturn promesa.protocols._then(promesa.protocols._promise(p),f);\n}));\n\n(promesa.core.then.cljs$core$IFn$_invoke$arity$3 = (function (p,f,executor){\nreturn promesa.protocols._then(promesa.protocols._promise(p),f,executor);\n}));\n\n(promesa.core.then.cljs$lang$maxFixedArity = 3);\n\npromesa.core.bind = (function promesa$core$bind(var_args){\nvar G__25383 = arguments.length;\nswitch (G__25383) {\ncase 2:\nreturn promesa.core.bind.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn promesa.core.bind.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\n(promesa.core.bind.cljs$core$IFn$_invoke$arity$2 = (function (p,f){\nreturn promesa.protocols._bind(promesa.protocols._promise(p),f);\n}));\n\n(promesa.core.bind.cljs$core$IFn$_invoke$arity$3 = (function (p,f,executor){\nreturn promesa.protocols._bind(promesa.protocols._promise(p),f,executor);\n}));\n\n(promesa.core.bind.cljs$lang$maxFixedArity = 3);\n\n/**\n * Chains a computation `f` (function) to be executed when the promise\n *   `p` is successfully resolved.\n * \n *   The computation will be executed in the calling thread by default;\n *   you also can provide a custom executor.\n * \n *   Don't perform flatten on the result.\n */\npromesa.core.then_SINGLEQUOTE_ = (function promesa$core$then_SINGLEQUOTE_(var_args){\nvar G__25385 = arguments.length;\nswitch (G__25385) {\ncase 2:\nreturn promesa.core.then_SINGLEQUOTE_.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn promesa.core.then_SINGLEQUOTE_.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\n(promesa.core.then_SINGLEQUOTE_.cljs$core$IFn$_invoke$arity$2 = (function (p,f){\nreturn promesa.protocols._map(promesa.protocols._promise(p),f);\n}));\n\n(promesa.core.then_SINGLEQUOTE_.cljs$core$IFn$_invoke$arity$3 = (function (p,f,executor){\nreturn promesa.protocols._map(promesa.protocols._promise(p),f,executor);\n}));\n\n(promesa.core.then_SINGLEQUOTE_.cljs$lang$maxFixedArity = 3);\n\n/**\n * Chains a computation `f` (function) to be executed when the promise\n *   `p` is successfully resolved.\n * \n *   Unlike `then` this does not performs automatic promise flattening.\n *   This is designed to be used with `->>`.\n */\npromesa.core.map = (function promesa$core$map(var_args){\nvar G__25387 = arguments.length;\nswitch (G__25387) {\ncase 2:\nreturn promesa.core.map.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn promesa.core.map.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\n(promesa.core.map.cljs$core$IFn$_invoke$arity$2 = (function (f,p){\nreturn promesa.protocols._map(promesa.protocols._promise(p),f);\n}));\n\n(promesa.core.map.cljs$core$IFn$_invoke$arity$3 = (function (executor,f,p){\nreturn promesa.protocols._map(promesa.protocols._promise(p),f,executor);\n}));\n\n(promesa.core.map.cljs$lang$maxFixedArity = 3);\n\n/**\n * Chains a computation `f` (function) to be executed when the promise\n *   `p` is successfully resolved. always expecting that `f` returns a\n *   promise that will be automatically unwrapped.\n * \n *   This is just a stricter version of `then` with reversed arguments in\n *   the same way as `map`.\n * \n *   This is designed to be used with `->>`.\n */\npromesa.core.mapcat = (function promesa$core$mapcat(var_args){\nvar G__25389 = arguments.length;\nswitch (G__25389) {\ncase 2:\nreturn promesa.core.mapcat.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn promesa.core.mapcat.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\n(promesa.core.mapcat.cljs$core$IFn$_invoke$arity$2 = (function (f,p){\nreturn promesa.protocols._bind(promesa.protocols._promise(p),f);\n}));\n\n(promesa.core.mapcat.cljs$core$IFn$_invoke$arity$3 = (function (executor,f,p){\nreturn promesa.protocols._bind(promesa.protocols._promise(p),f,executor);\n}));\n\n(promesa.core.mapcat.cljs$lang$maxFixedArity = 3);\n\n/**\n * Chain variable number of computations to be executed\n *   serially. Analogous to `then` that accepts variable number of\n *   functions.\n */\npromesa.core.chain = (function promesa$core$chain(var_args){\nvar G__25396 = arguments.length;\nswitch (G__25396) {\ncase 2:\nreturn promesa.core.chain.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nvar args_arr__5794__auto__ = [];\nvar len__5769__auto___25464 = arguments.length;\nvar i__5770__auto___25465 = (0);\nwhile(true){\nif((i__5770__auto___25465 < len__5769__auto___25464)){\nargs_arr__5794__auto__.push((arguments[i__5770__auto___25465]));\n\nvar G__25467 = (i__5770__auto___25465 + (1));\ni__5770__auto___25465 = G__25467;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__5795__auto__ = (new cljs.core.IndexedSeq(args_arr__5794__auto__.slice((2)),(0),null));\nreturn promesa.core.chain.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),argseq__5795__auto__);\n\n}\n});\n\n(promesa.core.chain.cljs$core$IFn$_invoke$arity$2 = (function (p,f){\nreturn promesa.core.then.cljs$core$IFn$_invoke$arity$2(p,f);\n}));\n\n(promesa.core.chain.cljs$core$IFn$_invoke$arity$variadic = (function (p,f,fs){\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3((function (p1__25390_SHARP_,p2__25391_SHARP_){\nreturn promesa.core.then.cljs$core$IFn$_invoke$arity$2(p1__25390_SHARP_,p2__25391_SHARP_);\n}),p,cljs.core.cons(f,fs));\n}));\n\n/** @this {Function} */\n(promesa.core.chain.cljs$lang$applyTo = (function (seq25393){\nvar G__25394 = cljs.core.first(seq25393);\nvar seq25393__$1 = cljs.core.next(seq25393);\nvar G__25395 = cljs.core.first(seq25393__$1);\nvar seq25393__$2 = cljs.core.next(seq25393__$1);\nvar self__5754__auto__ = this;\nreturn self__5754__auto__.cljs$core$IFn$_invoke$arity$variadic(G__25394,G__25395,seq25393__$2);\n}));\n\n(promesa.core.chain.cljs$lang$maxFixedArity = (2));\n\n/**\n * Chain variable number of computations to be executed serially. Unlike\n *   `chain` does not flattens the return value of each step (probably\n *   this is more performant than `chain`).\n */\npromesa.core.chain_SINGLEQUOTE_ = (function promesa$core$chain_SINGLEQUOTE_(var_args){\nvar G__25401 = arguments.length;\nswitch (G__25401) {\ncase 2:\nreturn promesa.core.chain_SINGLEQUOTE_.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nvar args_arr__5794__auto__ = [];\nvar len__5769__auto___25471 = arguments.length;\nvar i__5770__auto___25472 = (0);\nwhile(true){\nif((i__5770__auto___25472 < len__5769__auto___25471)){\nargs_arr__5794__auto__.push((arguments[i__5770__auto___25472]));\n\nvar G__25473 = (i__5770__auto___25472 + (1));\ni__5770__auto___25472 = G__25473;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__5795__auto__ = (new cljs.core.IndexedSeq(args_arr__5794__auto__.slice((2)),(0),null));\nreturn promesa.core.chain_SINGLEQUOTE_.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),argseq__5795__auto__);\n\n}\n});\n\n(promesa.core.chain_SINGLEQUOTE_.cljs$core$IFn$_invoke$arity$2 = (function (p,f){\nreturn promesa.core.then_SINGLEQUOTE_.cljs$core$IFn$_invoke$arity$2(p,f);\n}));\n\n(promesa.core.chain_SINGLEQUOTE_.cljs$core$IFn$_invoke$arity$variadic = (function (p,f,fs){\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(promesa.protocols._map,promesa.protocols._promise(p),cljs.core.cons(f,fs));\n}));\n\n/** @this {Function} */\n(promesa.core.chain_SINGLEQUOTE_.cljs$lang$applyTo = (function (seq25398){\nvar G__25399 = cljs.core.first(seq25398);\nvar seq25398__$1 = cljs.core.next(seq25398);\nvar G__25400 = cljs.core.first(seq25398__$1);\nvar seq25398__$2 = cljs.core.next(seq25398__$1);\nvar self__5754__auto__ = this;\nreturn self__5754__auto__.cljs$core$IFn$_invoke$arity$variadic(G__25399,G__25400,seq25398__$2);\n}));\n\n(promesa.core.chain_SINGLEQUOTE_.cljs$lang$maxFixedArity = (2));\n\n/**\n * Executes `f` when the promise `p` is resolved or is rejected. Returns\n *   a promise resolved with the return value of `f` function.\n */\npromesa.core.handle = (function promesa$core$handle(var_args){\nvar G__25403 = arguments.length;\nswitch (G__25403) {\ncase 2:\nreturn promesa.core.handle.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn promesa.core.handle.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\n(promesa.core.handle.cljs$core$IFn$_invoke$arity$2 = (function (p,f){\nreturn promesa.protocols._handle(promesa.protocols._promise(p),f);\n}));\n\n(promesa.core.handle.cljs$core$IFn$_invoke$arity$3 = (function (p,f,executor){\nreturn promesa.protocols._handle(promesa.protocols._promise(p),f,executor);\n}));\n\n(promesa.core.handle.cljs$lang$maxFixedArity = 3);\n\n/**\n * Attach a potentially side-effectful handler to promise that will be\n *   executed independently if promise is resolved or rejected.\n * \n *   Returns the original promise and the return value of `f` function is\n *   ignored.\n */\npromesa.core.finally$ = (function promesa$core$finally(var_args){\nvar G__25405 = arguments.length;\nswitch (G__25405) {\ncase 2:\nreturn promesa.core.finally$.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn promesa.core.finally$.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\n(promesa.core.finally$.cljs$core$IFn$_invoke$arity$2 = (function (p,f){\nreturn promesa.protocols._finally(promesa.protocols._promise(p),f);\n}));\n\n(promesa.core.finally$.cljs$core$IFn$_invoke$arity$3 = (function (p,f,executor){\nreturn promesa.protocols._finally(promesa.protocols._promise(p),f,executor);\n}));\n\n(promesa.core.finally$.cljs$lang$maxFixedArity = 3);\n\n/**\n * Executes `f` when the promise `p` is rejected. Returns a promise\n *   resolved with the return value of `f` function handler.\n */\npromesa.core.catch$ = (function promesa$core$catch(var_args){\nvar G__25408 = arguments.length;\nswitch (G__25408) {\ncase 2:\nreturn promesa.core.catch$.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn promesa.core.catch$.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\n(promesa.core.catch$.cljs$core$IFn$_invoke$arity$2 = (function (p,f){\nreturn promesa.protocols._thenErr(promesa.protocols._promise(p),f);\n}));\n\n(promesa.core.catch$.cljs$core$IFn$_invoke$arity$3 = (function (p,pred_or_type,f){\nvar accept_QMARK_ = ((cljs.core.ifn_QMARK_(pred_or_type))?pred_or_type:(function (p1__25406_SHARP_){\nreturn (p1__25406_SHARP_ instanceof pred_or_type);\n}));\nreturn promesa.protocols._thenErr(promesa.protocols._promise(p),(function (e){\nif(cljs.core.truth_((accept_QMARK_.cljs$core$IFn$_invoke$arity$1 ? accept_QMARK_.cljs$core$IFn$_invoke$arity$1(e) : accept_QMARK_.call(null,e)))){\nreturn (f.cljs$core$IFn$_invoke$arity$1 ? f.cljs$core$IFn$_invoke$arity$1(e) : f.call(null,e));\n} else {\nreturn promesa.impl.rejected(e);\n}\n}));\n}));\n\n(promesa.core.catch$.cljs$lang$maxFixedArity = 3);\n\n/**\n * Executes `f` when the promise `p` is rejected. Returns a promise\n *   resolved with the return value of `f` function handler.\n */\npromesa.core.catch_SINGLEQUOTE_ = (function promesa$core$catch_SINGLEQUOTE_(var_args){\nvar G__25411 = arguments.length;\nswitch (G__25411) {\ncase 2:\nreturn promesa.core.catch_SINGLEQUOTE_.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn promesa.core.catch_SINGLEQUOTE_.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\n(promesa.core.catch_SINGLEQUOTE_.cljs$core$IFn$_invoke$arity$2 = (function (p,f){\nreturn promesa.protocols._mapErr(promesa.protocols._promise(p),f);\n}));\n\n(promesa.core.catch_SINGLEQUOTE_.cljs$core$IFn$_invoke$arity$3 = (function (p,pred_or_type,f){\nvar accept_QMARK_ = ((cljs.core.ifn_QMARK_(pred_or_type))?pred_or_type:(function (p1__25409_SHARP_){\nreturn (p1__25409_SHARP_ instanceof pred_or_type);\n}));\nreturn promesa.protocols._mapErr(promesa.protocols._promise(p),(function (e){\nif(cljs.core.truth_((accept_QMARK_.cljs$core$IFn$_invoke$arity$1 ? accept_QMARK_.cljs$core$IFn$_invoke$arity$1(e) : accept_QMARK_.call(null,e)))){\nreturn (f.cljs$core$IFn$_invoke$arity$1 ? f.cljs$core$IFn$_invoke$arity$1(e) : f.call(null,e));\n} else {\nreturn promesa.impl.rejected(e);\n}\n}));\n}));\n\n(promesa.core.catch_SINGLEQUOTE_.cljs$lang$maxFixedArity = 3);\n\n/**\n * Same as `catch` but with parameters inverted.\n */\npromesa.core.error = (function promesa$core$error(var_args){\nvar G__25413 = arguments.length;\nswitch (G__25413) {\ncase 2:\nreturn promesa.core.error.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn promesa.core.error.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\n(promesa.core.error.cljs$core$IFn$_invoke$arity$2 = (function (f,p){\nreturn promesa.core.catch$.cljs$core$IFn$_invoke$arity$2(p,f);\n}));\n\n(promesa.core.error.cljs$core$IFn$_invoke$arity$3 = (function (f,type,p){\nreturn promesa.core.catch$.cljs$core$IFn$_invoke$arity$3(p,type,f);\n}));\n\n(promesa.core.error.cljs$lang$maxFixedArity = 3);\n\n/**\n * A short alias for `error` function.\n */\npromesa.core.err = promesa.core.error;\n/**\n * Given an array of promises, return a promise\n *   that is fulfilled  when all the items in the\n *   array are fulfilled.\n * \n *   Example:\n * \n *   (-> (all [(promise :first-promise)\n *          (promise :second-promise)]\n *    (then (fn [[first-result second-result]]))\n *     (println (str first-result \", \" second-result)\n * \n *   Will print out\n *   :first-promise, :second-promise.\n * \n *   If at least one of the promises is rejected, the resulting promise will be\n *   rejected.\n */\npromesa.core.all = (function promesa$core$all(promises){\nreturn promesa.core.then_SINGLEQUOTE_.cljs$core$IFn$_invoke$arity$2(promesa.impl._STAR_default_promise_STAR_.all(cljs.core.into_array.cljs$core$IFn$_invoke$arity$1(promises)),cljs.core.vec);\n});\npromesa.core.race = (function promesa$core$race(promises){\nreturn promesa.impl._STAR_default_promise_STAR_.race(cljs.core.into_array.cljs$core$IFn$_invoke$arity$1(cljs.core.map.cljs$core$IFn$_invoke$arity$2(promesa.protocols._promise,promises)));\n});\n/**\n * Given an array of promises, return a promise that is fulfilled when\n *   first one item in the array is fulfilled.\n */\npromesa.core.any = (function promesa$core$any(var_args){\nvar G__25415 = arguments.length;\nswitch (G__25415) {\ncase 1:\nreturn promesa.core.any.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn promesa.core.any.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\n(promesa.core.any.cljs$core$IFn$_invoke$arity$1 = (function (promises){\nreturn promesa.core.any.cljs$core$IFn$_invoke$arity$2(promises,new cljs.core.Keyword(\"promesa.core\",\"default\",\"promesa.core/default\",1773193826));\n}));\n\n(promesa.core.any.cljs$core$IFn$_invoke$arity$2 = (function (promises,default$){\nvar state = cljs.core.atom.cljs$core$IFn$_invoke$arity$1(new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,\"resolved\",\"resolved\",968763567),false,new cljs.core.Keyword(null,\"counter\",\"counter\",804008177),cljs.core.count(promises),new cljs.core.Keyword(null,\"rejections\",\"rejections\",-1620899911),cljs.core.PersistentVector.EMPTY], null));\nreturn promesa.core.create.cljs$core$IFn$_invoke$arity$1((function (resolve,reject){\nvar seq__25416 = cljs.core.seq(promises);\nvar chunk__25417 = null;\nvar count__25418 = (0);\nvar i__25419 = (0);\nwhile(true){\nif((i__25419 < count__25418)){\nvar p = chunk__25417.cljs$core$IIndexed$_nth$arity$2(null,i__25419);\npromesa.core.catch$.cljs$core$IFn$_invoke$arity$2(promesa.core.then.cljs$core$IFn$_invoke$arity$2(promesa.protocols._promise(p),((function (seq__25416,chunk__25417,count__25418,i__25419,p,state){\nreturn (function (v){\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"resolved\",\"resolved\",968763567).cljs$core$IFn$_invoke$arity$1(cljs.core.deref(state)))){\nreturn null;\n} else {\ncljs.core.swap_BANG_.cljs$core$IFn$_invoke$arity$2(state,((function (seq__25416,chunk__25417,count__25418,i__25419,p,state){\nreturn (function (state__$1){\nreturn cljs.core.update.cljs$core$IFn$_invoke$arity$3(cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(state__$1,new cljs.core.Keyword(null,\"resolved\",\"resolved\",968763567),true),new cljs.core.Keyword(null,\"counter\",\"counter\",804008177),cljs.core.dec);\n});})(seq__25416,chunk__25417,count__25418,i__25419,p,state))\n);\n\nreturn (resolve.cljs$core$IFn$_invoke$arity$1 ? resolve.cljs$core$IFn$_invoke$arity$1(v) : resolve.call(null,v));\n}\n});})(seq__25416,chunk__25417,count__25418,i__25419,p,state))\n),((function (seq__25416,chunk__25417,count__25418,i__25419,p,state){\nreturn (function (e){\ncljs.core.swap_BANG_.cljs$core$IFn$_invoke$arity$2(state,((function (seq__25416,chunk__25417,count__25418,i__25419,p,state){\nreturn (function (state__$1){\nreturn cljs.core.update.cljs$core$IFn$_invoke$arity$4(cljs.core.update.cljs$core$IFn$_invoke$arity$3(state__$1,new cljs.core.Keyword(null,\"counter\",\"counter\",804008177),cljs.core.dec),new cljs.core.Keyword(null,\"rejections\",\"rejections\",-1620899911),cljs.core.conj,e);\n});})(seq__25416,chunk__25417,count__25418,i__25419,p,state))\n);\n\nvar map__25424 = cljs.core.deref(state);\nvar map__25424__$1 = cljs.core.__destructure_map(map__25424);\nvar resolved = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__25424__$1,new cljs.core.Keyword(null,\"resolved\",\"resolved\",968763567));\nvar counter = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__25424__$1,new cljs.core.Keyword(null,\"counter\",\"counter\",804008177));\nvar rejections = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__25424__$1,new cljs.core.Keyword(null,\"rejections\",\"rejections\",-1620899911));\nif(((cljs.core.not(resolved)) && (cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(counter,(0))))){\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(default$,new cljs.core.Keyword(\"promesa.core\",\"default\",\"promesa.core/default\",1773193826))){\nvar G__25425 = cljs.core.ex_info.cljs$core$IFn$_invoke$arity$2(\"No promises resolved\",new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"rejections\",\"rejections\",-1620899911),rejections], null));\nreturn (reject.cljs$core$IFn$_invoke$arity$1 ? reject.cljs$core$IFn$_invoke$arity$1(G__25425) : reject.call(null,G__25425));\n} else {\nreturn (resolve.cljs$core$IFn$_invoke$arity$1 ? resolve.cljs$core$IFn$_invoke$arity$1(default$) : resolve.call(null,default$));\n}\n} else {\nreturn null;\n}\n});})(seq__25416,chunk__25417,count__25418,i__25419,p,state))\n);\n\n\nvar G__25515 = seq__25416;\nvar G__25516 = chunk__25417;\nvar G__25517 = count__25418;\nvar G__25518 = (i__25419 + (1));\nseq__25416 = G__25515;\nchunk__25417 = G__25516;\ncount__25418 = G__25517;\ni__25419 = G__25518;\ncontinue;\n} else {\nvar temp__5804__auto__ = cljs.core.seq(seq__25416);\nif(temp__5804__auto__){\nvar seq__25416__$1 = temp__5804__auto__;\nif(cljs.core.chunked_seq_QMARK_(seq__25416__$1)){\nvar c__5568__auto__ = cljs.core.chunk_first(seq__25416__$1);\nvar G__25521 = cljs.core.chunk_rest(seq__25416__$1);\nvar G__25522 = c__5568__auto__;\nvar G__25523 = cljs.core.count(c__5568__auto__);\nvar G__25524 = (0);\nseq__25416 = G__25521;\nchunk__25417 = G__25522;\ncount__25418 = G__25523;\ni__25419 = G__25524;\ncontinue;\n} else {\nvar p = cljs.core.first(seq__25416__$1);\npromesa.core.catch$.cljs$core$IFn$_invoke$arity$2(promesa.core.then.cljs$core$IFn$_invoke$arity$2(promesa.protocols._promise(p),((function (seq__25416,chunk__25417,count__25418,i__25419,p,seq__25416__$1,temp__5804__auto__,state){\nreturn (function (v){\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"resolved\",\"resolved\",968763567).cljs$core$IFn$_invoke$arity$1(cljs.core.deref(state)))){\nreturn null;\n} else {\ncljs.core.swap_BANG_.cljs$core$IFn$_invoke$arity$2(state,((function (seq__25416,chunk__25417,count__25418,i__25419,p,seq__25416__$1,temp__5804__auto__,state){\nreturn (function (state__$1){\nreturn cljs.core.update.cljs$core$IFn$_invoke$arity$3(cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(state__$1,new cljs.core.Keyword(null,\"resolved\",\"resolved\",968763567),true),new cljs.core.Keyword(null,\"counter\",\"counter\",804008177),cljs.core.dec);\n});})(seq__25416,chunk__25417,count__25418,i__25419,p,seq__25416__$1,temp__5804__auto__,state))\n);\n\nreturn (resolve.cljs$core$IFn$_invoke$arity$1 ? resolve.cljs$core$IFn$_invoke$arity$1(v) : resolve.call(null,v));\n}\n});})(seq__25416,chunk__25417,count__25418,i__25419,p,seq__25416__$1,temp__5804__auto__,state))\n),((function (seq__25416,chunk__25417,count__25418,i__25419,p,seq__25416__$1,temp__5804__auto__,state){\nreturn (function (e){\ncljs.core.swap_BANG_.cljs$core$IFn$_invoke$arity$2(state,((function (seq__25416,chunk__25417,count__25418,i__25419,p,seq__25416__$1,temp__5804__auto__,state){\nreturn (function (state__$1){\nreturn cljs.core.update.cljs$core$IFn$_invoke$arity$4(cljs.core.update.cljs$core$IFn$_invoke$arity$3(state__$1,new cljs.core.Keyword(null,\"counter\",\"counter\",804008177),cljs.core.dec),new cljs.core.Keyword(null,\"rejections\",\"rejections\",-1620899911),cljs.core.conj,e);\n});})(seq__25416,chunk__25417,count__25418,i__25419,p,seq__25416__$1,temp__5804__auto__,state))\n);\n\nvar map__25426 = cljs.core.deref(state);\nvar map__25426__$1 = cljs.core.__destructure_map(map__25426);\nvar resolved = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__25426__$1,new cljs.core.Keyword(null,\"resolved\",\"resolved\",968763567));\nvar counter = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__25426__$1,new cljs.core.Keyword(null,\"counter\",\"counter\",804008177));\nvar rejections = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__25426__$1,new cljs.core.Keyword(null,\"rejections\",\"rejections\",-1620899911));\nif(((cljs.core.not(resolved)) && (cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(counter,(0))))){\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(default$,new cljs.core.Keyword(\"promesa.core\",\"default\",\"promesa.core/default\",1773193826))){\nvar G__25427 = cljs.core.ex_info.cljs$core$IFn$_invoke$arity$2(\"No promises resolved\",new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"rejections\",\"rejections\",-1620899911),rejections], null));\nreturn (reject.cljs$core$IFn$_invoke$arity$1 ? reject.cljs$core$IFn$_invoke$arity$1(G__25427) : reject.call(null,G__25427));\n} else {\nreturn (resolve.cljs$core$IFn$_invoke$arity$1 ? resolve.cljs$core$IFn$_invoke$arity$1(default$) : resolve.call(null,default$));\n}\n} else {\nreturn null;\n}\n});})(seq__25416,chunk__25417,count__25418,i__25419,p,seq__25416__$1,temp__5804__auto__,state))\n);\n\n\nvar G__25533 = cljs.core.next(seq__25416__$1);\nvar G__25534 = null;\nvar G__25535 = (0);\nvar G__25536 = (0);\nseq__25416 = G__25533;\nchunk__25417 = G__25534;\ncount__25418 = G__25535;\ni__25419 = G__25536;\ncontinue;\n}\n} else {\nreturn null;\n}\n}\nbreak;\n}\n}));\n}));\n\n(promesa.core.any.cljs$lang$maxFixedArity = 2);\n\n/**\n * A promise aware run! function.\n */\npromesa.core.run_BANG_ = (function promesa$core$run_BANG_(var_args){\nvar G__25431 = arguments.length;\nswitch (G__25431) {\ncase 2:\nreturn promesa.core.run_BANG_.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn promesa.core.run_BANG_.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\n(promesa.core.run_BANG_.cljs$core$IFn$_invoke$arity$2 = (function (f,coll){\nreturn promesa.core.run_BANG_.cljs$core$IFn$_invoke$arity$3(f,coll,promesa.exec.current_thread_executor);\n}));\n\n(promesa.core.run_BANG_.cljs$core$IFn$_invoke$arity$3 = (function (f,coll,executor){\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3((function (p1__25428_SHARP_,p2__25429_SHARP_){\nreturn promesa.core.then.cljs$core$IFn$_invoke$arity$2(p1__25428_SHARP_,(function (_){\nreturn (f.cljs$core$IFn$_invoke$arity$1 ? f.cljs$core$IFn$_invoke$arity$1(p2__25429_SHARP_) : f.call(null,p2__25429_SHARP_));\n}));\n}),promesa.core.promise.cljs$core$IFn$_invoke$arity$2(null,executor),coll);\n}));\n\n(promesa.core.run_BANG_.cljs$lang$maxFixedArity = 3);\n\n/**\n * Cancel the promise.\n */\npromesa.core.cancel_BANG_ = (function promesa$core$cancel_BANG_(p){\npromesa.protocols._cancel_BANG_(p);\n\nreturn p;\n});\n/**\n * Return true if `v` is a cancelled promise.\n */\npromesa.core.cancelled_QMARK_ = (function promesa$core$cancelled_QMARK_(v){\nreturn promesa.protocols._cancelled_QMARK_(v);\n});\n/**\n * Resolve a completable promise with a value.\n */\npromesa.core.resolve_BANG_ = (function promesa$core$resolve_BANG_(var_args){\nvar G__25433 = arguments.length;\nswitch (G__25433) {\ncase 1:\nreturn promesa.core.resolve_BANG_.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn promesa.core.resolve_BANG_.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\n(promesa.core.resolve_BANG_.cljs$core$IFn$_invoke$arity$1 = (function (o){\nreturn promesa.protocols._resolve_BANG_(o,null);\n}));\n\n(promesa.core.resolve_BANG_.cljs$core$IFn$_invoke$arity$2 = (function (o,v){\nreturn promesa.protocols._resolve_BANG_(o,v);\n}));\n\n(promesa.core.resolve_BANG_.cljs$lang$maxFixedArity = 2);\n\n/**\n * Reject a completable promise with an error.\n */\npromesa.core.reject_BANG_ = (function promesa$core$reject_BANG_(p,e){\nreturn promesa.protocols._reject_BANG_(p,e);\n});\n/**\n * Given a function that accepts a callback as the last argument return other\n *   function that returns a promise. Callback is expected to take single\n *   parameter (result of a computation).\n */\npromesa.core.promisify = (function promesa$core$promisify(callable){\nreturn (function() { \nvar G__25545__delegate = function (args){\nreturn promesa.core.create.cljs$core$IFn$_invoke$arity$1((function (resolve,reject){\nvar args__$1 = cljs.core.conj.cljs$core$IFn$_invoke$arity$2(cljs.core.vec(args),resolve);\ntry{return cljs.core.apply.cljs$core$IFn$_invoke$arity$2(callable,args__$1);\n}catch (e25434){if((e25434 instanceof Error)){\nvar e = e25434;\nreturn (reject.cljs$core$IFn$_invoke$arity$1 ? reject.cljs$core$IFn$_invoke$arity$1(e) : reject.call(null,e));\n} else {\nthrow e25434;\n\n}\n}}));\n};\nvar G__25545 = function (var_args){\nvar args = null;\nif (arguments.length > 0) {\nvar G__25547__i = 0, G__25547__a = new Array(arguments.length -  0);\nwhile (G__25547__i < G__25547__a.length) {G__25547__a[G__25547__i] = arguments[G__25547__i + 0]; ++G__25547__i;}\n  args = new cljs.core.IndexedSeq(G__25547__a,0,null);\n} \nreturn G__25545__delegate.call(this,args);};\nG__25545.cljs$lang$maxFixedArity = 0;\nG__25545.cljs$lang$applyTo = (function (arglist__25548){\nvar args = cljs.core.seq(arglist__25548);\nreturn G__25545__delegate(args);\n});\nG__25545.cljs$core$IFn$_invoke$arity$variadic = G__25545__delegate;\nreturn G__25545;\n})()\n;\n});\n/**\n * @constructor\n */\npromesa.core.TimeoutException = (function promesa$core$TimeoutException(message){\nvar it = this;\nError.call(it,message,cljs.core.PersistentArrayMap.EMPTY,null);\n\nreturn it;\n});\ngoog.inherits(promesa.core.TimeoutException,Error);\n/**\n * Returns a cancellable promise that will be fulfilled with this\n *   promise's fulfillment value or rejection reason.  However, if this\n *   promise is not fulfilled or rejected within `ms` milliseconds, the\n *   returned promise is cancelled with a TimeoutError\n */\npromesa.core.timeout = (function promesa$core$timeout(var_args){\nvar G__25436 = arguments.length;\nswitch (G__25436) {\ncase 2:\nreturn promesa.core.timeout.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn promesa.core.timeout.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase 4:\nreturn promesa.core.timeout.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\n(promesa.core.timeout.cljs$core$IFn$_invoke$arity$2 = (function (p,t){\nreturn promesa.core.timeout.cljs$core$IFn$_invoke$arity$4(p,t,new cljs.core.Keyword(\"promesa.core\",\"default\",\"promesa.core/default\",1773193826),promesa.exec.default_scheduler);\n}));\n\n(promesa.core.timeout.cljs$core$IFn$_invoke$arity$3 = (function (p,t,v){\nreturn promesa.core.timeout.cljs$core$IFn$_invoke$arity$4(p,t,v,promesa.exec.default_scheduler);\n}));\n\n(promesa.core.timeout.cljs$core$IFn$_invoke$arity$4 = (function (p,t,v,scheduler){\nvar timeout = promesa.core.deferred();\nvar tid = promesa.exec.schedule_BANG_.cljs$core$IFn$_invoke$arity$3(scheduler,t,(function (){\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(v,new cljs.core.Keyword(\"promesa.core\",\"default\",\"promesa.core/default\",1773193826))){\nreturn promesa.core.reject_BANG_(timeout,(new promesa.core.TimeoutException(\"Operation timed out.\")));\n} else {\nreturn promesa.core.resolve_BANG_.cljs$core$IFn$_invoke$arity$2(timeout,v);\n}\n}));\nreturn promesa.core.race(new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [promesa.core.finally$.cljs$core$IFn$_invoke$arity$2(p,(function (_,___$1){\nreturn promesa.protocols._cancel_BANG_(tid);\n})),timeout], null));\n}));\n\n(promesa.core.timeout.cljs$lang$maxFixedArity = 4);\n\n/**\n * Given a timeout in miliseconds and optional value, returns a promise\n *   that will fulfilled with provided value (or nil) after the time is\n *   reached.\n */\npromesa.core.delay = (function promesa$core$delay(var_args){\nvar G__25438 = arguments.length;\nswitch (G__25438) {\ncase 1:\nreturn promesa.core.delay.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn promesa.core.delay.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn promesa.core.delay.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\n(promesa.core.delay.cljs$core$IFn$_invoke$arity$1 = (function (t){\nreturn promesa.core.delay.cljs$core$IFn$_invoke$arity$3(t,null,promesa.exec.default_scheduler);\n}));\n\n(promesa.core.delay.cljs$core$IFn$_invoke$arity$2 = (function (t,v){\nreturn promesa.core.delay.cljs$core$IFn$_invoke$arity$3(t,v,promesa.exec.default_scheduler);\n}));\n\n(promesa.core.delay.cljs$core$IFn$_invoke$arity$3 = (function (t,v,scheduler){\nvar d = promesa.core.deferred();\npromesa.exec.schedule_BANG_.cljs$core$IFn$_invoke$arity$3(scheduler,t,(function (){\nreturn promesa.core.resolve_BANG_.cljs$core$IFn$_invoke$arity$2(d,v);\n}));\n\nreturn d;\n}));\n\n(promesa.core.delay.cljs$lang$maxFixedArity = 3);\n\npromesa.core._STAR_loop_run_fn_STAR_ = promesa.exec.run_BANG_;\n","~:ns-info",["^ ","~:rename-macros",null,"~:renames",["^ "],"~:meta",["^ ","~:file","promesa/core.cljc","~:line",25,"~:column",5,"~:end-line",25,"~:end-column",17],"~:ns-aliases",["^ ","~$cljs.loader","~$shadow.loader","~$clojure.pprint","~$cljs.pprint","~$clojure.spec.alpha","~$cljs.spec.alpha","~$clojure.core","~$cljs.core"],"~:use-macros",null,"~:excludes",["~#set",["~$map","~$delay","~$mapcat","~$await","~$let","~$->","~$future","~$as->","~$do","~$spread","~$promise","~$run!","~$recur","~$loop","~$with-redefs","~$->>"]],"~:macros",["^ ","~$do!",["^ ","~:arglists",["~#list",[["~$&","~$exprs"]]],"~:doc","Execute potentially side effectful code and return a promise resolved\n  to the last expression. Always awaiting the result of each\n  expression.","^7",422,"^8",1,"^6","promesa/core.cljc","~:name","~$promesa.core/do!","~:ns","~$promesa.core","~:macro",true],"^K",["^ ","^Y",["^Z",[["~$bindings","~$&","~$body"]]],"^10","A `let` alternative that always returns promise and waits for all the\n  promises on the bindings.","^7",444,"^8",1,"^6","promesa/core.cljc","^11","~$promesa.core/let","^13","^14","^15",true],"^L",["^ ","^Y",["^Z",[["~$x","~$&","~$forms"]]],"^10","Like the clojure.core/->, but it will handle promises in values\n  and make sure the next form gets the value realized instead of\n  the promise. Example using to fetch data in the browser with CLJS:\n\n  Example:\n\n  (p/-> (js/fetch #js {...}) ; returns a promise\n        .-body)\n\n  The result of a thread is a promise that will resolve to the\n  end of the thread chain.","^7",515,"^8",1,"^6","promesa/core.cljc","^11","~$promesa.core/->","^13","^14","^15",true],"^M",["^ ","^Y",["^Z",[["~$&","^17"]]],"^10","Analogous to `clojure.core/future` that returns a promise instance\n  instead of the `Future`. Usefull for execute synchronous code in a\n  separate thread (also works in cljs).","^7",468,"^8",1,"^6","promesa/core.cljc","^11","~$promesa.core/future","^13","^14","^15",true],"~$plet",["^ ","^Y",["^Z",[["^16","~$&","^17"]]],"^10","A parallel let; executes all the bindings in parallel and when all\n  bindings are resolved, executes the body.","^7",456,"^8",1,"^6","promesa/core.cljc","^11","~$promesa.core/plet","^13","^14","^15",true],"^N",["^ ","^Y",["^Z",[["~$expr","~$name","~$&","^19"]]],"^10","Like clojure.core/as->, but it will handle promises in values\n   and make sure the next form gets the value realized instead of\n   the promise.","^7",557,"^8",1,"^6","promesa/core.cljc","^11","~$promesa.core/as->","^13","^14","^15",true],"^O",["^ ","^Y",["^Z",[["~$&","^["]]],"^10","An alias for do!","^7",439,"^8",1,"^6","promesa/core.cljc","^11","~$promesa.core/do","^13","^14","^15",true],"^S",["^ ","^Y",["^Z",[["~$&","~$args"]]],"^7",511,"^8",1,"^6","promesa/core.cljc","^11","~$promesa.core/recur","^13","^14","^15",true],"^T",["^ ","^Y",["^Z",[["^16","~$&","^17"]]],"^7",480,"^8",1,"^6","promesa/core.cljc","^11","~$promesa.core/loop","^13","^14","^15",true],"^U",["^ ","^Y",["^Z",[["^16","~$&","^17"]]],"^10","Like clojure.core/with-redefs, but it will handle promises in\n   body and wait until they resolve or reject before restoring the\n   bindings. Useful for mocking async APIs.","^7",568,"^8",1,"^6","promesa/core.cljc","^11","~$promesa.core/with-redefs","^13","^14","^15",true],"^V",["^ ","^Y",["^Z",[["~$x","~$&","^19"]]],"^10","Like the clojure.core/->>, but it will handle promises in values\n  and make sure the next form gets the value realized instead of\n  the promise. Example using to fetch data in the browser with CLJS:\n\n  Example:\n\n  (p/->> (js/fetch #js {...}) ; returns a promise\n         .-body\n         read-string\n         (mapv inc)\n\n  The result of a thread is a promise that will resolve to the\n  end of the thread chain.","^7",535,"^8",1,"^6","promesa/core.cljc","^11","~$promesa.core/->>","^13","^14","^15",true]],"^11","^14","~:reader-aliases",["^ "],"~:op","^13","~:imports",null,"~:requires",["^ ","~$impl","~$promesa.impl","~$promesa.protocols","^1M","^C","^C","~$pt","^1M","~$goog","^1O","~$exec","~$promesa.exec","^1Q","^1Q","^B","^C","^1L","^1L","~$c","^C"],"~:seen",["^F",["~:require","~:require-macros"]],"~:uses",null,"^1T",["^ ","^14","^14","^C","^C","^B","^C","~$c","^C"],"~:form",["^Z",["~$ns","^14",["^Z",["~:refer-clojure","~:exclude",["^H","^P","^Q","^J","^G","^I","^R","^M","^K","^T","^S","^L","^V","^N","^U","^O"]]],["^Z",["^1S",["^1M","~:as","^1N"],["^B","^1Z","~$c"],["^1Q","^1Z","^1P"],["^1L","^1Z","^1K"]]],["^Z",["^1T",["^14"]]]]],"~:flags",["^ ","^1S",["^F",[]],"^1T",["^F",[]]],"~:js-deps",["^ "],"~:deps",["^1O","^C","^1M","^C","^1Q","^1L"]],"^13","^14","~:resource-id",["~:shadow.build.classpath/resource","promesa/core.cljc"],"~:compiled-at",1748825683817,"^1G",["^ ","^1K","^1L","^1M","^1M","^14","^14","^C","^C","^1N","^1M","^1O","^1O","^1P","^1Q","^1Q","^1Q","^B","^C","^1L","^1L","~$c","^C"],"~:resource-name","promesa/core.cljc","~:warnings",[],"~:source",";; Copyright (c) 2015-2019 Andrey Antukh <niwi@niwi.nz>\n;; All rights reserved.\n;;\n;; Redistribution and use in source and binary forms, with or without\n;; modification, are permitted provided that the following conditions\n;; are met:\n;;\n;; 1. Redistributions of source code must retain the above copyright\n;;    notice, this list of conditions and the following disclaimer.\n;; 2. Redistributions in binary form must reproduce the above copyright\n;;    notice, this list of conditions and the following disclaimer in the\n;;    documentation and/or other materials provided with the distribution.\n;;\n;; THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n;; IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n;; OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n;; IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,\n;; INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n;; NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n;; DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n;; THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n;; (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n;; THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n(ns promesa.core\n  (:refer-clojure :exclude [delay spread promise\n                            await map mapcat run!\n                            future let loop recur\n                            -> ->> as-> with-redefs do])\n  (:require\n   [promesa.protocols :as pt]\n   [clojure.core :as c]\n   [promesa.exec :as exec]\n   [promesa.impl :as impl])\n  #?(:cljs (:require-macros [promesa.core]))\n  #?(:clj\n     (:import\n      java.util.concurrent.CompletableFuture\n      java.util.concurrent.CompletionStage\n      java.util.concurrent.TimeoutException)))\n\n;; --- Promise\n\n(defn resolved\n  \"Return a resolved promise with provided value.\"\n  [v]\n  (impl/resolved v))\n\n(defn rejected\n  \"Return a rejected promise with provided reason.\"\n  [v]\n  (impl/rejected v))\n\n(defn deferred\n  \"Creates an empty promise instance.\"\n  []\n  (impl/deferred))\n\n(defn promise\n  \"The coerce based promise constructor. Creates a appropriate promise\n  instance depending on the provided value.\n\n  If an executor is provided, it will be used to resolve this\n  promise.\"\n  ([v]\n   (pt/-promise v))\n  ([v executor]\n   (pt/-map (pt/-promise v) identity executor)))\n\n(defn wrap\n  \"A convenience alias for `promise` coercion function that only accepts\n  a single argument.\"\n  [v]\n  (pt/-promise v))\n\n(defn create\n  \"Create a promise instance from a factory function. If an executor is\n  provided, the factory will be executed in the provided executor.\n\n  A factory function looks like `(fn [resolve reject] (resolve 1))`.\"\n  ([f]\n   (c/let [d (impl/deferred)]\n     (try\n       (f #(pt/-resolve! d %)\n          #(pt/-reject! d %))\n       (catch #?(:clj Exception :cljs :default) e\n         (pt/-reject! d e)))\n     d))\n  ([f executor]\n   (c/let [d (impl/deferred)]\n     (exec/run! executor (fn []\n                           (try\n                             (f #(pt/-resolve! d %)\n                                #(pt/-reject! d %))\n                             (catch #?(:clj Exception :cljs :default) e\n                               (pt/-reject! d e)))))\n     d)))\n\n(defn promise?\n  \"Return true if `v` is a promise instance.\"\n  [v]\n  (satisfies? pt/IPromise v))\n\n  ;; #?(:clj (instance? CompletionStage v)\n  ;;    :cljs (instance? impl/*default-promise* v)))\n\n(defn deferred?\n  \"Return true if `v` is a promise instance (alias to `promise?`).\"\n  [v]\n  #?(:clj (instance? CompletionStage v)\n     :cljs (instance? impl/*default-promise* v)))\n\n#?(:cljs\n   (defn thenable?\n     \"Returns true if `v` is a promise like object.\"\n     [v]\n     (and (object? v) (fn? (unchecked-get v \"then\")))))\n\n;; Predicates\n\n(defn resolved?\n  \"Returns true if promise `p` is already fulfilled.\"\n  [p]\n  (pt/-resolved? p))\n\n(defn rejected?\n  \"Returns true if promise `p` is already rejected.\"\n  [p]\n  (pt/-rejected? p))\n\n(defn pending?\n  \"Returns true if promise `p` is stil pending.\"\n  [p]\n  (pt/-pending? p))\n\n(defn extract\n  \"Returns the current promise value.\"\n  [p]\n  (pt/-extract p))\n\n(def done?\n  \"Returns true if promise `p` is already done.\"\n  (complement pending?))\n\n;; Chaining\n\n(defn then\n  \"Chains a computation `f` (function) to be executed when the promise\n  `p` is successfully resolved.\n\n  The computation will be executed in the calling thread by default;\n  you also can provide a custom executor.\n\n  If the function `f` returns a promise instance, it will be\n  automatically unwrapped.\"\n  ([p f]\n   (pt/-then (pt/-promise p) f))\n  ([p f executor]\n   (pt/-then (pt/-promise p) f executor)))\n\n(defn bind\n  ([p f]\n   (pt/-bind (pt/-promise p) f))\n  ([p f executor]\n   (pt/-bind (pt/-promise p) f executor)))\n\n(defn then'\n  \"Chains a computation `f` (function) to be executed when the promise\n  `p` is successfully resolved.\n\n  The computation will be executed in the calling thread by default;\n  you also can provide a custom executor.\n\n  Don't perform flatten on the result.\"\n  ([p f]\n   (pt/-map (pt/-promise p) f))\n  ([p f executor]\n   (pt/-map (pt/-promise p) f executor)))\n\n(defn map\n  \"Chains a computation `f` (function) to be executed when the promise\n  `p` is successfully resolved.\n\n  Unlike `then` this does not performs automatic promise flattening.\n  This is designed to be used with `->>`.\"\n  ([f p]\n   (pt/-map (pt/-promise p) f))\n  ([executor f p]\n   (pt/-map (pt/-promise p) f executor)))\n\n(defn mapcat\n  \"Chains a computation `f` (function) to be executed when the promise\n  `p` is successfully resolved. always expecting that `f` returns a\n  promise that will be automatically unwrapped.\n\n  This is just a stricter version of `then` with reversed arguments in\n  the same way as `map`.\n\n  This is designed to be used with `->>`.\"\n  ([f p]\n   (pt/-bind (pt/-promise p) f))\n  ([executor f p]\n   (pt/-bind (pt/-promise p) f executor)))\n\n(defn chain\n  \"Chain variable number of computations to be executed\n  serially. Analogous to `then` that accepts variable number of\n  functions.\"\n  ([p f] (then p f))\n  ([p f & fs] (reduce #(then %1 %2) p (cons f fs))))\n\n(defn chain'\n  \"Chain variable number of computations to be executed serially. Unlike\n  `chain` does not flattens the return value of each step (probably\n  this is more performant than `chain`).\"\n  ([p f] (then' p f))\n  ([p f & fs] (reduce pt/-map (pt/-promise p) (cons f fs))))\n\n(defn handle\n  \"Executes `f` when the promise `p` is resolved or is rejected. Returns\n  a promise resolved with the return value of `f` function.\"\n  ([p f]\n   (pt/-handle (pt/-promise p) f))\n  ([p f executor]\n   (pt/-handle (pt/-promise p) f executor)))\n\n(defn finally\n  \"Attach a potentially side-effectful handler to promise that will be\n  executed independently if promise is resolved or rejected.\n\n  Returns the original promise and the return value of `f` function is\n  ignored.\"\n  ([p f]\n   (pt/-finally (pt/-promise p) f))\n  ([p f executor]\n   (pt/-finally (pt/-promise p) f executor)))\n\n(defn catch\n  \"Executes `f` when the promise `p` is rejected. Returns a promise\n  resolved with the return value of `f` function handler.\"\n  ([p f]\n   (pt/-thenErr (pt/-promise p) f))\n  ([p pred-or-type f]\n   (c/let [accept? (if (ifn? pred-or-type)\n                     pred-or-type\n                     #(instance? pred-or-type %))]\n     (pt/-thenErr\n      (pt/-promise p)\n      (fn [e]\n        (if (accept? e)\n          (f e)\n          (impl/rejected e)))))))\n\n(defn catch'\n  \"Executes `f` when the promise `p` is rejected. Returns a promise\n  resolved with the return value of `f` function handler.\"\n  ([p f]\n   (pt/-mapErr (pt/-promise p) f))\n  ([p pred-or-type f]\n   (c/let [accept? (if (ifn? pred-or-type)\n                     pred-or-type\n                     #(instance? pred-or-type %))]\n     (pt/-mapErr\n      (pt/-promise p)\n      (fn [e]\n        (if (accept? e)\n          (f e)\n          (impl/rejected e)))))))\n\n(defn error\n  \"Same as `catch` but with parameters inverted.\"\n  ([f p] (catch p f))\n  ([f type p] (catch p type f)))\n\n(def err\n  \"A short alias for `error` function.\"\n  error)\n\n(defn all\n  \"Given an array of promises, return a promise\n  that is fulfilled  when all the items in the\n  array are fulfilled.\n\n  Example:\n\n  (-> (all [(promise :first-promise)\n            (promise :second-promise)]\n      (then (fn [[first-result second-result]]))\n       (println (str first-result \\\", \\\" second-result)\n\n  Will print out\n  :first-promise, :second-promise.\n\n  If at least one of the promises is rejected, the resulting promise will be\n  rejected.\"\n  [promises]\n  #?(:cljs (c/-> (.all impl/*default-promise* (into-array promises))\n                 (then' vec))\n     :clj (c/let [promises (clojure.core/map pt/-promise promises)]\n            (then' (c/->> (into-array CompletableFuture promises)\n                          (CompletableFuture/allOf))\n                   (fn [_]\n                     (mapv pt/-extract promises))))))\n\n(defn race\n  [promises]\n  #?(:cljs (.race impl/*default-promise* (into-array (cljs.core/map pt/-promise promises)))\n     :clj (CompletableFuture/anyOf (c/->> (clojure.core/map pt/-promise promises)\n                                          (into-array CompletableFuture)))))\n\n(defn any\n  \"Given an array of promises, return a promise that is fulfilled when\n  first one item in the array is fulfilled.\"\n  ([promises]\n   (any promises ::default))\n  ([promises default]\n   (c/let [state (atom {:resolved false\n                        :counter (count promises)\n                        :rejections []})]\n     (create\n      (fn [resolve reject]\n        (doseq [p promises]\n          (c/-> (pt/-promise p)\n                (then (fn [v]\n                        (when-not (:resolved @state)\n                          (swap! state (fn [state]\n                                         (c/-> state\n                                               (assoc :resolved true)\n                                               (update :counter dec))))\n                          (resolve v))))\n                (catch (fn [e]\n                         (swap! state (fn [state]\n                                        (c/-> state\n                                              (update  :counter dec)\n                                              (update :rejections conj e))))\n                         (c/let [{:keys [resolved counter rejections]} @state]\n                           (when (and (not resolved) (= counter 0))\n                             (if (= default ::default)\n                               (reject (ex-info \"No promises resolved\"\n                                                {:rejections rejections}))\n                               (resolve default)))))))))))))\n\n(defn run!\n  \"A promise aware run! function.\"\n  ([f coll] (run! f coll exec/current-thread-executor))\n  ([f coll executor] (reduce #(then %1 (fn [_] (f %2))) (promise nil executor) coll)))\n\n;; Cancellation\n\n(defn cancel!\n  \"Cancel the promise.\"\n  [p]\n  (pt/-cancel! p)\n  p)\n\n(defn cancelled?\n  \"Return true if `v` is a cancelled promise.\"\n  [v]\n  (pt/-cancelled? v))\n\n;; Completable\n\n(defn resolve!\n  \"Resolve a completable promise with a value.\"\n  ([o] (pt/-resolve! o nil))\n  ([o v] (pt/-resolve! o v)))\n\n(defn reject!\n  \"Reject a completable promise with an error.\"\n  [p e]\n  (pt/-reject! p e))\n\n;; --- Utils\n\n(defn promisify\n  \"Given a function that accepts a callback as the last argument return other\n  function that returns a promise. Callback is expected to take single\n  parameter (result of a computation).\"\n  [callable]\n  (fn [& args]\n    (create (fn [resolve reject]\n               (c/let [args (c/-> (vec args) (conj resolve))]\n                 (try\n                   (apply callable args)\n                   (catch #?(:clj Throwable :cljs js/Error) e\n                     (reject e))))))))\n\n#?(:cljs\n   (defn ^{:jsdoc [\"@constructor\"]}\n     TimeoutException [message]\n     (this-as it\n       (.call js/Error it message {} nil)\n       it)))\n\n#?(:cljs (goog/inherits TimeoutException js/Error))\n\n(defn timeout\n  \"Returns a cancellable promise that will be fulfilled with this\n  promise's fulfillment value or rejection reason.  However, if this\n  promise is not fulfilled or rejected within `ms` milliseconds, the\n  returned promise is cancelled with a TimeoutError\"\n  ([p t] (timeout p t ::default exec/default-scheduler))\n  ([p t v] (timeout p t v exec/default-scheduler))\n  ([p t v scheduler]\n   (c/let [timeout (deferred)\n           tid     (exec/schedule! scheduler t #(if (= v ::default)\n                                                  (reject! timeout (TimeoutException. \"Operation timed out.\"))\n                                                  (resolve! timeout v)))]\n     (race [(finally p (fn [_ _] (pt/-cancel! tid))) timeout]))))\n\n(defn delay\n  \"Given a timeout in miliseconds and optional value, returns a promise\n  that will fulfilled with provided value (or nil) after the time is\n  reached.\"\n  ([t] (delay t nil exec/default-scheduler))\n  ([t v] (delay t v exec/default-scheduler))\n  ([t v scheduler]\n   (c/let [d (deferred)]\n     (exec/schedule! scheduler t #(resolve! d v))\n     d)))\n\n(defmacro do!\n  \"Execute potentially side effectful code and return a promise resolved\n  to the last expression. Always awaiting the result of each\n  expression.\"\n  [& exprs]\n  `(pt/-bind\n    (pt/-promise nil)\n    (fn [_#]\n      ~(condp = (count exprs)\n         0 `(pt/-promise nil)\n         1 `(pt/-promise ~(first exprs))\n         (reduce (fn [acc e]\n                   `(pt/-bind (pt/-promise ~e) (fn [_#] ~acc)))\n                 `(pt/-promise ~(last exprs))\n                 (reverse (butlast exprs)))))))\n\n\n(defmacro do\n  \"An alias for do!\"\n  [& exprs]\n  `(do! ~@exprs))\n\n(defmacro let\n  \"A `let` alternative that always returns promise and waits for all the\n  promises on the bindings.\"\n  [bindings & body]\n  `(pt/-bind\n    (pt/-promise nil)\n    (fn [_#]\n      ~(c/->> (reverse (partition 2 bindings))\n              (reduce (fn [acc [l r]]\n                        `(pt/-bind (pt/-promise ~r) (fn [~l] ~acc)))\n                      `(do! ~@body))))))\n\n(defmacro plet\n  \"A parallel let; executes all the bindings in parallel and when all\n  bindings are resolved, executes the body.\"\n  [bindings & body]\n  `(pt/-bind\n    (pt/-promise nil)\n    (fn [_#]\n      ~(c/let [bindings (partition 2 bindings)]\n         `(c/-> (all ~(mapv second bindings))\n                (then (fn [[~@(mapv first bindings)]]\n                        (do! ~@body))))))))\n\n(defmacro future\n  \"Analogous to `clojure.core/future` that returns a promise instance\n  instead of the `Future`. Usefull for execute synchronous code in a\n  separate thread (also works in cljs).\"\n  [& body]\n  `(c/-> (exec/submit! (fn []\n                         (c/let [f# (fn [] ~@body)]\n                           (pt/-promise (f#)))))\n         (pt/-bind identity)))\n\n(def ^:dynamic *loop-run-fn* exec/run!)\n\n(defmacro loop\n  [bindings & body]\n  (c/let [bindings (partition 2 2 bindings)\n          names (mapv first bindings)\n          fvals (mapv second bindings)\n          tsym (gensym \"loop\")\n          dsym (gensym \"deferred\")\n          rsym (gensym \"run\")]\n    `(c/let [~rsym *loop-run-fn*\n             ~dsym (promesa.core/deferred)\n             ~tsym (fn ~tsym [params#]\n                     (c/-> (promesa.core/all params#)\n                           (promesa.core/then (fn [[~@names]]\n                                                ;; (prn \"exec\" ~@names)\n                                                (do! ~@body)))\n                           (promesa.core/handle\n                            (fn [res# err#]\n                              ;; (prn \"result\" res# err#)\n                              (cond\n                                (not (nil? err#))\n                                (promesa.core/reject! ~dsym err#)\n\n                                (and (map? res#) (= (:type res#) :promesa.core/recur))\n                                (do (~rsym (fn [] (~tsym (:args res#))))\n                                    nil)\n\n                                :else\n                                (promesa.core/resolve! ~dsym res#))))))]\n       (~rsym (fn [] (~tsym ~fvals)))\n       ~dsym)))\n\n(defmacro recur\n  [& args]\n  `(array-map :type :promesa.core/recur :args [~@args]))\n\n(defmacro ->\n  \"Like the clojure.core/->, but it will handle promises in values\n  and make sure the next form gets the value realized instead of\n  the promise. Example using to fetch data in the browser with CLJS:\n\n  Example:\n\n  (p/-> (js/fetch #js {...}) ; returns a promise\n        .-body)\n\n  The result of a thread is a promise that will resolve to the\n  end of the thread chain.\"\n  [x & forms]\n  (c/let [fns (mapv (fn [arg]\n                      (c/let [[f & args] (if (sequential? arg)\n                                           arg\n                                           (list arg))]\n                        `(fn [p#] (~f p# ~@args)))) forms)]\n    `(chain (promise ~x) ~@fns)))\n\n(defmacro ->>\n  \"Like the clojure.core/->>, but it will handle promises in values\n  and make sure the next form gets the value realized instead of\n  the promise. Example using to fetch data in the browser with CLJS:\n\n  Example:\n\n  (p/->> (js/fetch #js {...}) ; returns a promise\n         .-body\n         read-string\n         (mapv inc)\n\n  The result of a thread is a promise that will resolve to the\n  end of the thread chain.\"\n  [x & forms]\n  (c/let [fns (mapv (fn [arg]\n                      (c/let [[f & args] (if (sequential? arg)\n                                           arg\n                                           (list arg))]\n                        `(fn [p#] (~f ~@args p#)))) forms)]\n    `(chain (promise ~x) ~@fns)))\n\n(defmacro as->\n  \"Like clojure.core/as->, but it will handle promises in values\n   and make sure the next form gets the value realized instead of\n   the promise.\"\n  [expr name & forms]\n  `(let [~name ~expr\n         ~@(interleave (repeat name) (butlast forms))]\n     ~(if (empty? forms)\n        name\n        (last forms))))\n\n(defmacro with-redefs\n  \"Like clojure.core/with-redefs, but it will handle promises in\n   body and wait until they resolve or reject before restoring the\n   bindings. Useful for mocking async APIs.\"\n  [bindings & body]\n  (c/let [names         (take-nth 2 bindings)\n          vals          (take-nth 2 (drop 1 bindings))\n          orig-val-syms (c/map (comp gensym #(str % \"-orig-val__\") name) names)\n          temp-val-syms (c/map (comp gensym #(str % \"-temp-val__\") name) names)\n          binds         (c/map vector names temp-val-syms)\n          resets        (reverse (c/map vector names orig-val-syms))\n          bind-value    (if (:ns &env)\n                          (fn [[k v]] (list 'set! k v))\n                          (fn [[k v]] (list 'alter-var-root (list 'var k) (list 'constantly v))))]\n    `(c/let [~@(interleave orig-val-syms names)\n             ~@(interleave temp-val-syms vals)]\n       ~@(c/map bind-value binds)\n       (c/-> (promesa.core/do! ~@body)\n             (promesa.core/finally\n               (fn [_# _#]\n                 ~@(c/map bind-value resets)))))))\n","~:reader-features",["^F",["~:cljs"]],"~:cljc",true,"~:source-map-compact",["^ ","mappings","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","names",["promesa.core/resolved","v","promesa.impl/resolved","promesa.core/rejected","promesa.impl/rejected","promesa.core/deferred","promesa.impl/deferred","var_args","G__25366","promesa.core/promise","js/Error","promesa.protocols/-promise","executor","promesa.protocols/-map","cljs.core/identity","promesa.core/wrap","G__25372","promesa.core/create","f","d","e25373","G__25374","p1__25367#","G__25375","p1__25368#","promesa.protocols/-resolve!","promesa.protocols/-reject!","e","promesa.exec.run_BANG_","e25376","G__25377","p1__25369#","G__25378","p1__25370#","promesa.core/promise?","cljs.core/PROTOCOL_SENTINEL","cljs.core/native-satisfies?","promesa.protocols/IPromise","promesa.core/deferred?","promesa.impl/*default-promise*","promesa.core/thenable?","cljs.core/object?","cljs.core/fn?","promesa.core/resolved?","p","promesa.protocols/-resolved?","promesa.core/rejected?","promesa.protocols/-rejected?","promesa.core/pending?","promesa.protocols/-pending?","promesa.core/extract","promesa.protocols/-extract","promesa.core/done?","cljs.core/complement","G__25381","promesa.core/then","promesa.protocols/-then","G__25383","promesa.core/bind","promesa.protocols/-bind","G__25385","promesa.core/then'","G__25387","promesa.core/map","G__25389","promesa.core/mapcat","G__25396","promesa.core/chain","args-arr__5794__auto__","len__5769__auto__","i__5770__auto__","argseq__5795__auto__","cljs.core/IndexedSeq","seq25393","G__25394","cljs.core/first","cljs.core/next","G__25395","self__5754__auto__","promesa.core.then","fs","p1__25390#","p2__25391#","cljs.core.reduce","cljs.core/cons","G__25401","promesa.core/chain'","seq25398","G__25399","G__25400","promesa.core.then_SINGLEQUOTE_","G__25403","promesa.core/handle","promesa.protocols/-handle","G__25405","promesa.core/finally","promesa.protocols/-finally","G__25408","promesa.core/catch","promesa.protocols/-thenErr","pred-or-type","accept?","p1__25406#","cljs.core/ifn?","G__25411","promesa.core/catch'","promesa.protocols/-mapErr","p1__25409#","G__25413","promesa.core/error","promesa.core.catch$","type","promesa.core/err","promesa.core/all","promises","cljs.core.into_array","cljs.core/vec","promesa.core/race","cljs.core.map","G__25415","promesa.core/any","promesa.core.any","default","state","cljs.core.atom","cljs.core/count","promesa.core.create","resolve","reject","seq__25416","cljs.core/seq","chunk__25417","count__25418","i__25419","temp__5804__auto__","cljs.core/chunked-seq?","c__5568__auto__","cljs.core/chunk-first","cljs.core/chunk-rest","cljs.core/deref","cljs.core.swap_BANG_","cljs.core.assoc","cljs.core.update","cljs.core/dec","cljs.core/conj","map__25424","cljs.core/--destructure-map","cljs.core.get","map__25426","resolved","counter","rejections","cljs.core/not","cljs.core._EQ_","G__25425","G__25427","cljs.core.ex_info","G__25431","promesa.core/run!","coll","promesa.core.run_BANG_","promesa.exec/current-thread-executor","p1__25428#","p2__25429#","_","promesa.core.promise","promesa.core/cancel!","promesa.protocols/-cancel!","promesa.core/cancelled?","promesa.protocols/-cancelled?","G__25433","promesa.core/resolve!","o","promesa.core/reject!","promesa.core/promisify","callable","args","cljs.core.conj","e25434","cljs.core.apply","promesa.core/TimeoutException","message","it","goog/inherits","G__25436","promesa.core/timeout","t","promesa.core.timeout","promesa.exec/default-scheduler","scheduler","timeout","tid","promesa.exec.schedule_BANG_","promesa.core.resolve_BANG_","promesa.core.finally$","G__25438","promesa.core/delay","promesa.core.delay","promesa.core/*loop-run-fn*","promesa.exec/run!"]],"~:used-vars",["^F",["~$cljs.core/--destructure-map","~$promesa.core/promise","~$promesa.core/resolve!","~$cljs.core/PROTOCOL_SENTINEL","~$promesa.core/promisify","~$promesa.protocols/-reject!","~$promesa.core/mapcat","~$promesa.protocols/-resolve!","~$promesa.protocols/-map","~$cljs.core/=","~$cljs.core/dec","~$promesa.core/catch","~$cljs.core/ifn?","~$cljs.core/into-array","~$cljs.core/IndexedSeq","~$cljs.core/count","~$cljs.core/deref","~$promesa.core/extract","~$cljs.core/reduce","~$cljs.core/seq","~$cljs.core/chunk-first","~$cljs.core/apply","~$promesa.core/rejected?","~$cljs.core/identity","~$promesa.core/rejected","~$promesa.core/run!","~$promesa.protocols/-promise","~$cljs.core/chunk-rest","~$cljs.core/atom","~$promesa.core/TimeoutException","~$promesa.impl/rejected","~$promesa.core/wrap","~$promesa.core/bind","~$cljs.core/native-satisfies?","~$promesa.protocols/-then","~$promesa.core/deferred","~$cljs.core/conj","~$promesa.protocols/-extract","~$promesa.core/then'","~$goog/inherits","~$promesa.core/resolved?","~$cljs.core/update","~$promesa.core/map","~$cljs.core/map","~$promesa.core/chain'","~$promesa.core/all","~$cljs.core/fn?","~$promesa.core/cancelled?","~$promesa.impl/*default-promise*","~$promesa.core/resolved","~$promesa.protocols/-cancelled?","~$cljs.core/swap!","~$promesa.protocols/-thenErr","~$promesa.core/pending?","~$cljs.core/get","~$promesa.impl/deferred","~$cljs.core/-nth","~$promesa.protocols/-resolved?","~$cljs.core/object?","~$promesa.impl/resolved","~$promesa.core/handle","~$promesa.core/catch'","~$promesa.core/error","~$promesa.core/race","~$promesa.core/create","~$cljs.core/ex-info","~$promesa.protocols/-pending?","~$promesa.core/thenable?","~$promesa.core/cancel!","~$promesa.core/finally","~$promesa.protocols/-handle","~$promesa.core/done?","~$cljs.core/next","~$cljs.core/vec","~$promesa.core/then","~$promesa.core/any","~$promesa.exec/default-scheduler","~$promesa.core/deferred?","~$promesa.protocols/-finally","~$cljs.core/not","~$cljs.core/complement","~$promesa.protocols/-rejected?","~$cljs.core/cons","~$cljs.core/assoc","~$promesa.protocols/-cancel!","~$promesa.protocols/-mapErr","~$promesa.core/delay","~$promesa.core/chain","~$promesa.core/timeout","~$cljs.core/first","~$promesa.core/promise?","~$promesa.protocols/IPromise","~$promesa.core/err","~$promesa.protocols/-bind","~$promesa.exec/schedule!","~$js/Error","~$promesa.exec/current-thread-executor","~$promesa.core/*loop-run-fn*","~$promesa.exec/run!","~$cljs.core/chunked-seq?","~$promesa.core/reject!"]]],"~:cache-keys",["~#cmap",[["^23","goog/dom/tagname.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","~:shadow.build.compiler/resolve",["^ ","~:require-id",null,"~:deps-ids",["^F",[]],"~:deps-syms",["^1O","~$goog.dom.HtmlElement"]]],["^23","goog/html/trustedtypes.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^4N",["^ ","^4O",null,"^4P",["^F",[]],"^4Q",["^1O"]]],["^23","goog/labs/useragent/browser.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^4N",["^ ","^4O",null,"^4P",["^F",[]],"^4Q",["^1O","~$goog.array","~$goog.object","~$goog.labs.userAgent.util","~$goog.string.internal"]]],["^23","goog/html/safeurl.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^4N",["^ ","^4O",null,"^4P",["^F",[]],"^4Q",["^1O","~$goog.asserts","~$goog.fs.url","~$goog.html.TrustedResourceUrl","~$goog.i18n.bidi.Dir","~$goog.i18n.bidi.DirectionalString","~$goog.string.Const","~$goog.string.TypedString","^4V"]]],["^23","goog/array/array.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^4N",["^ ","^4O",null,"^4P",["^F",[]],"^4Q",["^1O","^4W"]]],["^23","goog/debug/error.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^4N",["^ ","^4O",null,"^4P",["^F",[]],"^4Q",["^1O"]]],["^23","promesa/impl.cljc"],["6acd9dfa95d916dd8c99e4ec2a1b8cc0c3ef9919","^4N",["^ ","^4O",null,"^4P",["^F",[]],"^4Q",["^1O","^C","^1M","~$promesa.util","^1Q"]]],["^23","goog/dom/nodetype.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^4N",["^ ","^4O",null,"^4P",["^F",[]],"^4Q",["^1O"]]],["^23","goog/string/typedstring.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^4N",["^ ","^4O",null,"^4P",["^F",[]],"^4Q",["^1O"]]],["^23","goog/object/object.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^4N",["^ ","^4O",null,"^4P",["^F",[]],"^4Q",["^1O"]]],["^23","goog/dom/asserts.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^4N",["^ ","^4O",null,"^4P",["^F",[]],"^4Q",["^1O","^4W"]]],"~:SHADOW-TIMESTAMP",[1748825659000,1748825659000,1748819812000],["^23","promesa/util.cljc"],["6acd9dfa95d916dd8c99e4ec2a1b8cc0c3ef9919","^4N",["^ ","^4O",null,"^4P",["^F",[]],"^4Q",["^1O","^C"]]],["^23","goog/math/long.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^4N",["^ ","^4O",null,"^4P",["^F",[]],"^4Q",["^1O","^4W","~$goog.reflect"]]],["^23","goog/html/trustedresourceurl.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^4N",["^ ","^4O",null,"^4P",["^F",[]],"^4Q",["^1O","^4W","~$goog.fs.blob","^4X","~$goog.html.SafeScript","~$goog.html.trustedtypes","^4Z","^4[","^50","^51"]]],["^23","goog/string/internal.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^4N",["^ ","^4O",null,"^4P",["^F",[]],"^4Q",["^1O"]]],["^23","goog/functions/functions.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^4N",["^ ","^4O",null,"^4P",["^F",[]],"^4Q",["^1O"]]],["^23","goog/html/safestyle.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^4N",["^ ","^4O",null,"^4P",["^F",[]],"^4Q",["^1O","^50","~$goog.html.SafeUrl","^51","^4W","^4V"]]],["^23","goog/dom/safe.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^4N",["^ ","^4O",null,"^4P",["^F",[]],"^4Q",["^1O","^4W","~$goog.dom.asserts","~$goog.functions","~$goog.html.SafeHtml","^56","~$goog.html.SafeStyle","^58","^4Y","~$goog.html.uncheckedconversions","^50","^4V"]]],["^23","goog/html/safehtml.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^4N",["^ ","^4O",null,"^4P",["^F",[]],"^4Q",["^1O","^50","^4Z","^4[","^56","^5<","~$goog.html.SafeStyleSheet","^58","~$goog.dom.TagName","^4Y","^51","^4W","~$goog.labs.userAgent.browser","^4S","^4T","^4V","~$goog.dom.tags","^57"]]],["^23","goog/dom/tags.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^4N",["^ ","^4O",null,"^4P",["^F",[]],"^4Q",["^1O","^4T"]]],["^23","goog/fs/blob.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^4N",["^ ","^4O",null,"^4P",["^F",[]],"^4Q",["^1O"]]],["^23","goog/asserts/asserts.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^4N",["^ ","^4O",null,"^4P",["^F",[]],"^4Q",["^1O","~$goog.debug.Error","~$goog.dom.NodeType"]]],["^23","goog/uri/uri.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^4N",["^ ","^4O",null,"^4P",["^F",[]],"^4Q",["^1O","^4S","^4W","~$goog.collections.maps","~$goog.string","~$goog.structs","~$goog.uri.utils","~$goog.uri.utils.ComponentIndex","~$goog.uri.utils.StandardQueryParam"]]],["^23","goog/collections/maps.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^4N",["^ ","^4O",null,"^4P",["^F",[]],"^4Q",["^1O"]]],["^23","goog/i18n/bidi.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^4N",["^ ","^4O",null,"^4P",["^F",[]],"^4Q",["^1O"]]],["^23","goog/fs/url.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^4N",["^ ","^4O",null,"^4P",["^F",[]],"^4Q",["^1O"]]],["^23","goog/base.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^4N",["^ ","^4O",null,"^4P",["^F",[]],"^4Q",[]]],["^23","promesa/core.cljc"],["6acd9dfa95d916dd8c99e4ec2a1b8cc0c3ef9919","^4N",["^ ","^4O",null,"^4P",["^F",[]],"^4Q",["^1O","^C","^1M","^C","^1Q","^1L"]]],["^23","goog/structs/structs.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^4N",["^ ","^4O",null,"^4P",["^F",[]],"^4Q",["^1O","^4S","^4T"]]],["^23","goog/string/string.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^4N",["^ ","^4O",null,"^4P",["^F",[]],"^4Q",["^1O","~$goog.dom.safe","^5=","^50","^4V"]]],["^23","goog/reflect/reflect.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^4N",["^ ","^4O",null,"^4P",["^F",[]],"^4Q",["^1O"]]],["^23","goog/labs/useragent/util.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^4N",["^ ","^4O",null,"^4P",["^F",[]],"^4Q",["^1O","~$goog.labs.userAgent","^4V"]]],["^23","goog/string/stringbuffer.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^4N",["^ ","^4O",null,"^4P",["^F",[]],"^4Q",["^1O"]]],["^23","promesa/protocols.cljc"],["6acd9dfa95d916dd8c99e4ec2a1b8cc0c3ef9919","^4N",["^ ","^4O",null,"^4P",["^F",[]],"^4Q",["^1O","^C"]]],["^23","goog/labs/useragent/useragent.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^4N",["^ ","^4O",null,"^4P",["^F",[]],"^4Q",["^1O"]]],["^23","goog/html/uncheckedconversions.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^4N",["^ ","^4O",null,"^4P",["^F",[]],"^4Q",["^1O","^4W","^5;","^56","^5<","^5>","^58","^4Y","^50","^4V","^4Z"]]],["^23","goog/dom/htmlelement.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^4N",["^ ","^4O",null,"^4P",["^F",[]],"^4Q",["^1O"]]],["^23","cljs/core.cljs"],["bc14df6666853ed869d7b88aaa864111c65d0c7f","^4N",["^ ","^4O",null,"^4P",["^F",[]],"^4Q",["^1O","~$goog.math.Long","~$goog.math.Integer","^5E","^4T","^4S","~$goog.Uri","~$goog.string.StringBuffer"]]],["^23","goog/html/safescript.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^4N",["^ ","^4O",null,"^4P",["^F",[]],"^4Q",["^1O","^50","^51","^57","^4W"]]],["^23","goog/html/safestylesheet.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^4N",["^ ","^4O",null,"^4P",["^F",[]],"^4Q",["^1O","^50","^5<","^51","^4T","^4W","^4V"]]],["^23","goog/math/integer.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^4N",["^ ","^4O",null,"^4P",["^F",[]],"^4Q",["^1O","^54"]]],["^23","goog/uri/utils.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^4N",["^ ","^4O",null,"^4P",["^F",[]],"^4Q",["^1O","^4W","^5E"]]],["^23","goog/string/const.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^4N",["^ ","^4O",null,"^4P",["^F",[]],"^4Q",["^1O","^4W","^51"]]],["^23","promesa/exec.cljc"],["6acd9dfa95d916dd8c99e4ec2a1b8cc0c3ef9919","^4N",["^ ","^4O",null,"^4P",["^F",[]],"^4Q",["^1O","^C","^1M","^52","^4T"]]]]],"~:clj-info",["^ ","jar:file:/home/xuelin/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/vendor/clojure/tools/reader/reader_types.clj",1748819812000,"jar:file:/home/xuelin/.m2/repository/org/clojure/clojure/1.11.1/clojure-1.11.1.jar!/clojure/java/io.clj",1736537829000,"jar:file:/home/xuelin/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/tagged_literals.cljc",1748819812000,"jar:file:/home/xuelin/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/analyzer.cljc",1748819812000,"jar:file:/home/xuelin/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/util.cljc",1748819812000,"jar:file:/home/xuelin/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/source_map.clj",1748819812000,"jar:file:/home/xuelin/.m2/repository/org/clojure/clojure/1.11.1/clojure-1.11.1.jar!/clojure/string.clj",1736537829000,"jar:file:/home/xuelin/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/externs.clj",1748819812000,"jar:file:/home/xuelin/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/analyzer/impl.cljc",1748819812000,"jar:file:/home/xuelin/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/core.cljc",1748819812000,"jar:file:/home/xuelin/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/source_map/base64.clj",1748819812000,"jar:file:/home/xuelin/.m2/repository/org/clojure/clojure/1.11.1/clojure-1.11.1.jar!/clojure/pprint.clj",1736537829000,"jar:file:/home/xuelin/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/instant.clj",1748819812000,"jar:file:/home/xuelin/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/vendor/clojure/tools/reader/impl/inspect.clj",1748819812000,"jar:file:/home/xuelin/.m2/repository/funcool/promesa/8.0.446/promesa-8.0.446.jar!/promesa/impl.cljc",1748825426000,"jar:file:/home/xuelin/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/vendor/clojure/tools/reader/default_data_readers.clj",1748819812000,"jar:file:/home/xuelin/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/analyzer/passes.cljc",1748819812000,"jar:file:/home/xuelin/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/vendor/clojure/tools/reader.clj",1748819812000,"jar:file:/home/xuelin/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/js_deps.cljc",1748819812000,"jar:file:/home/xuelin/.m2/repository/org/clojure/clojure/1.11.1/clojure-1.11.1.jar!/clojure/set.clj",1736537829000,"jar:file:/home/xuelin/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/vendor/clojure/data/json.clj",1748819812000,"jar:file:/home/xuelin/.m2/repository/org/clojure/clojure/1.11.1/clojure-1.11.1.jar!/clojure/instant.clj",1736537829000,"jar:file:/home/xuelin/.m2/repository/funcool/promesa/8.0.446/promesa-8.0.446.jar!/promesa/exec.cljc",1748825426000,"jar:file:/home/xuelin/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/source_map/base64_vlq.clj",1748819812000,"jar:file:/home/xuelin/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/vendor/clojure/tools/reader/impl/errors.clj",1748819812000,"jar:file:/home/xuelin/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/env.cljc",1748819812000,"jar:file:/home/xuelin/.m2/repository/funcool/promesa/8.0.446/promesa-8.0.446.jar!/promesa/protocols.cljc",1748825426000,"jar:file:/home/xuelin/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/compiler.cljc",1748819812000,"jar:file:/home/xuelin/.m2/repository/org/clojure/clojure/1.11.1/clojure-1.11.1.jar!/clojure/core.clj",1736537829000,"jar:file:/home/xuelin/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/analyzer/passes/and_or.cljc",1748819812000,"jar:file:/home/xuelin/.m2/repository/funcool/promesa/8.0.446/promesa-8.0.446.jar!/promesa/core.cljc",1748825426000,"jar:file:/home/xuelin/.m2/repository/org/clojure/clojure/1.11.1/clojure-1.11.1.jar!/clojure/edn.clj",1736537829000,"jar:file:/home/xuelin/.m2/repository/funcool/promesa/8.0.446/promesa-8.0.446.jar!/promesa/util.cljc",1748825426000,"jar:file:/home/xuelin/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/analyzer/impl/namespaces.cljc",1748819812000],"~:analyzer",["^ ","^3",null,"^4",["^ "],"^5",["^ ","^6","promesa/core.cljc","^7",25,"^8",5,"^9",25,"^:",17],"^;",["^ ","^<","^=","^>","^?","^@","^A","^B","^C"],"^D",null,"^E",["^F",["^G","^H","^I","^J","^K","^L","^M","^N","^O","^P","^Q","^R","^S","^T","^U","^V"]],"^W",["^ ","^X",["^ ","^Y",["^Z",[["~$&","^["]]],"^10","Execute potentially side effectful code and return a promise resolved\n  to the last expression. Always awaiting the result of each\n  expression.","^7",422,"^8",1,"^6","promesa/core.cljc","^11","^12","^13","^14","^15",true],"^K",["^ ","^Y",["^Z",[["^16","~$&","^17"]]],"^10","A `let` alternative that always returns promise and waits for all the\n  promises on the bindings.","^7",444,"^8",1,"^6","promesa/core.cljc","^11","^18","^13","^14","^15",true],"^L",["^ ","^Y",["^Z",[["~$x","~$&","^19"]]],"^10","Like the clojure.core/->, but it will handle promises in values\n  and make sure the next form gets the value realized instead of\n  the promise. Example using to fetch data in the browser with CLJS:\n\n  Example:\n\n  (p/-> (js/fetch #js {...}) ; returns a promise\n        .-body)\n\n  The result of a thread is a promise that will resolve to the\n  end of the thread chain.","^7",515,"^8",1,"^6","promesa/core.cljc","^11","^1:","^13","^14","^15",true],"^M",["^ ","^Y",["^Z",[["~$&","^17"]]],"^10","Analogous to `clojure.core/future` that returns a promise instance\n  instead of the `Future`. Usefull for execute synchronous code in a\n  separate thread (also works in cljs).","^7",468,"^8",1,"^6","promesa/core.cljc","^11","^1;","^13","^14","^15",true],"^1<",["^ ","^Y",["^Z",[["^16","~$&","^17"]]],"^10","A parallel let; executes all the bindings in parallel and when all\n  bindings are resolved, executes the body.","^7",456,"^8",1,"^6","promesa/core.cljc","^11","^1=","^13","^14","^15",true],"^N",["^ ","^Y",["^Z",[["^1>","^1?","~$&","^19"]]],"^10","Like clojure.core/as->, but it will handle promises in values\n   and make sure the next form gets the value realized instead of\n   the promise.","^7",557,"^8",1,"^6","promesa/core.cljc","^11","^1@","^13","^14","^15",true],"^O",["^ ","^Y",["^Z",[["~$&","^["]]],"^10","An alias for do!","^7",439,"^8",1,"^6","promesa/core.cljc","^11","^1A","^13","^14","^15",true],"^S",["^ ","^Y",["^Z",[["~$&","^1B"]]],"^7",511,"^8",1,"^6","promesa/core.cljc","^11","^1C","^13","^14","^15",true],"^T",["^ ","^Y",["^Z",[["^16","~$&","^17"]]],"^7",480,"^8",1,"^6","promesa/core.cljc","^11","^1D","^13","^14","^15",true],"^U",["^ ","^Y",["^Z",[["^16","~$&","^17"]]],"^10","Like clojure.core/with-redefs, but it will handle promises in\n   body and wait until they resolve or reject before restoring the\n   bindings. Useful for mocking async APIs.","^7",568,"^8",1,"^6","promesa/core.cljc","^11","^1E","^13","^14","^15",true],"^V",["^ ","^Y",["^Z",[["~$x","~$&","^19"]]],"^10","Like the clojure.core/->>, but it will handle promises in values\n  and make sure the next form gets the value realized instead of\n  the promise. Example using to fetch data in the browser with CLJS:\n\n  Example:\n\n  (p/->> (js/fetch #js {...}) ; returns a promise\n         .-body\n         read-string\n         (mapv inc)\n\n  The result of a thread is a promise that will resolve to the\n  end of the thread chain.","^7",535,"^8",1,"^6","promesa/core.cljc","^11","^1F","^13","^14","^15",true]],"^11","^14","^1G",["^ "],"^1I",null,"^1J",["^ ","^1K","^1L","^1M","^1M","^C","^C","^1N","^1M","^1O","^1O","^1P","^1Q","^1Q","^1Q","^B","^C","^1L","^1L","~$c","^C"],"^1R",["^F",["^1S","^1T"]],"~:shadow/js-access-global",["^F",["Error"]],"^1U",null,"~:defs",["^ ","~$timeout",["^ ","~:protocol-inline",null,"^5",["^ ","^6","promesa/core.cljc","^7",397,"^8",7,"^9",397,"^:",14,"^Y",["^Z",["~$quote",["^Z",[["~$p","~$t"],["~$p","~$t","~$v"],["~$p","~$t","~$v","~$scheduler"]]]]],"^10","Returns a cancellable promise that will be fulfilled with this\n  promise's fulfillment value or rejection reason.  However, if this\n  promise is not fulfilled or rejected within `ms` milliseconds, the\n  returned promise is cancelled with a TimeoutError","~:top-fn",["^ ","~:variadic?",false,"~:fixed-arity",4,"~:max-fixed-arity",4,"~:method-params",[["~$p","~$t"],["~$p","~$t","~$v"],["~$p","~$t","~$v","^6M"]],"^Y",["^Z",[["~$p","~$t"],["~$p","~$t","~$v"],["~$p","~$t","~$v","^6M"]]],"~:arglists-meta",["^Z",[null,null,null]]]],"^11","^4?","^6","promesa/core.cljc","^:",14,"^6N",["^ ","^6O",false,"^6P",4,"^6Q",4,"^6R",[["~$p","~$t"],["~$p","~$t","~$v"],["~$p","~$t","~$v","^6M"]],"^Y",["^Z",[["~$p","~$t"],["~$p","~$t","~$v"],["~$p","~$t","~$v","^6M"]]],"^6S",["^Z",[null,null,null]]],"^6R",[["~$p","~$t"],["~$p","~$t","~$v"],["~$p","~$t","~$v","^6M"]],"~:protocol-impl",null,"^6P",4,"^6S",["^Z",[null,null,null]],"^8",1,"^6O",false,"~:methods",[["^ ","^6P",2,"^6O",false,"~:tag","~$any"],["^ ","^6P",3,"^6O",false,"^6V","^6W"],["^ ","^6P",4,"^6O",false,"^6V","^6W"]],"^7",397,"^9",397,"^6Q",4,"~:fn-var",true,"^Y",["^Z",[["~$p","~$t"],["~$p","~$t","~$v"],["~$p","~$t","~$v","^6M"]]],"^10","Returns a cancellable promise that will be fulfilled with this\n  promise's fulfillment value or rejection reason.  However, if this\n  promise is not fulfilled or rejected within `ms` milliseconds, the\n  returned promise is cancelled with a TimeoutError"],"~$deferred?",["^ ","^6K",null,"^5",["^ ","^6","promesa/core.cljc","^7",107,"^8",7,"^9",107,"^:",16,"^Y",["^Z",["^6L",["^Z",[["~$v"]]]]],"^10","Return true if `v` is a promise instance (alias to `promise?`)."],"^11","^44","^6","promesa/core.cljc","^:",16,"^6R",["^Z",[["~$v"]]],"^6T",null,"^6S",["^Z",[null,null]],"^8",1,"^6O",false,"^7",107,"~:ret-tag","~$boolean","^9",107,"^6Q",1,"^6X",true,"^Y",["^Z",["^6L",["^Z",[["~$v"]]]]],"^10","Return true if `v` is a promise instance (alias to `promise?`)."],"^G",["^ ","^6K",null,"^5",["^ ","^6","promesa/core.cljc","^7",180,"^8",7,"^9",180,"^:",10,"^Y",["^Z",["^6L",["^Z",[["~$f","~$p"],["~$executor","~$f","~$p"]]]]],"^10","Chains a computation `f` (function) to be executed when the promise\n  `p` is successfully resolved.\n\n  Unlike `then` this does not performs automatic promise flattening.\n  This is designed to be used with `->>`.","^6N",["^ ","^6O",false,"^6P",3,"^6Q",3,"^6R",[["~$f","~$p"],["^70","~$f","~$p"]],"^Y",["^Z",[["~$f","~$p"],["^70","~$f","~$p"]]],"^6S",["^Z",[null,null]]]],"^11","^3=","^6","promesa/core.cljc","^:",10,"^6N",["^ ","^6O",false,"^6P",3,"^6Q",3,"^6R",[["~$f","~$p"],["^70","~$f","~$p"]],"^Y",["^Z",[["~$f","~$p"],["^70","~$f","~$p"]]],"^6S",["^Z",[null,null]]],"^6R",[["~$f","~$p"],["^70","~$f","~$p"]],"^6T",null,"^6P",3,"^6S",["^Z",[null,null]],"^8",1,"^6O",false,"^6U",[["^ ","^6P",2,"^6O",false,"^6V","^6W"],["^ ","^6P",3,"^6O",false,"^6V","^6W"]],"^7",180,"^9",180,"^6Q",3,"^6X",true,"^Y",["^Z",[["~$f","~$p"],["^70","~$f","~$p"]]],"^10","Chains a computation `f` (function) to be executed when the promise\n  `p` is successfully resolved.\n\n  Unlike `then` this does not performs automatic promise flattening.\n  This is designed to be used with `->>`."],"^H",["^ ","^6K",null,"^5",["^ ","^6","promesa/core.cljc","^7",411,"^8",7,"^9",411,"^:",12,"^Y",["^Z",["^6L",["^Z",[["~$t"],["~$t","~$v"],["~$t","~$v","^6M"]]]]],"^10","Given a timeout in miliseconds and optional value, returns a promise\n  that will fulfilled with provided value (or nil) after the time is\n  reached.","^6N",["^ ","^6O",false,"^6P",3,"^6Q",3,"^6R",[["~$t"],["~$t","~$v"],["~$t","~$v","^6M"]],"^Y",["^Z",[["~$t"],["~$t","~$v"],["~$t","~$v","^6M"]]],"^6S",["^Z",[null,null,null]]]],"^11","^4=","^6","promesa/core.cljc","^:",12,"^6N",["^ ","^6O",false,"^6P",3,"^6Q",3,"^6R",[["~$t"],["~$t","~$v"],["~$t","~$v","^6M"]],"^Y",["^Z",[["~$t"],["~$t","~$v"],["~$t","~$v","^6M"]]],"^6S",["^Z",[null,null,null]]],"^6R",[["~$t"],["~$t","~$v"],["~$t","~$v","^6M"]],"^6T",null,"^6P",3,"^6S",["^Z",[null,null,null]],"^8",1,"^6O",false,"^6U",[["^ ","^6P",1,"^6O",false,"^6V","^6W"],["^ ","^6P",2,"^6O",false,"^6V","^6W"],["^ ","^6P",3,"^6O",false,"^6V","^3C"]],"^7",411,"^9",411,"^6Q",3,"^6X",true,"^Y",["^Z",[["~$t"],["~$t","~$v"],["~$t","~$v","^6M"]]],"^10","Given a timeout in miliseconds and optional value, returns a promise\n  that will fulfilled with provided value (or nil) after the time is\n  reached."],"~$resolved?",["^ ","^6K",null,"^5",["^ ","^6","promesa/core.cljc","^7",121,"^8",7,"^9",121,"^:",16,"^Y",["^Z",["^6L",["^Z",[["~$p"]]]]],"^10","Returns true if promise `p` is already fulfilled."],"^11","^3;","^6","promesa/core.cljc","^:",16,"^6R",["^Z",[["~$p"]]],"^6T",null,"^6S",["^Z",[null,null]],"^8",1,"^6O",false,"^7",121,"^6Z","^6W","^9",121,"^6Q",1,"^6X",true,"^Y",["^Z",["^6L",["^Z",[["~$p"]]]]],"^10","Returns true if promise `p` is already fulfilled."],"^I",["^ ","^6K",null,"^5",["^ ","^6","promesa/core.cljc","^7",191,"^8",7,"^9",191,"^:",13,"^Y",["^Z",["^6L",["^Z",[["~$f","~$p"],["^70","~$f","~$p"]]]]],"^10","Chains a computation `f` (function) to be executed when the promise\n  `p` is successfully resolved. always expecting that `f` returns a\n  promise that will be automatically unwrapped.\n\n  This is just a stricter version of `then` with reversed arguments in\n  the same way as `map`.\n\n  This is designed to be used with `->>`.","^6N",["^ ","^6O",false,"^6P",3,"^6Q",3,"^6R",[["~$f","~$p"],["^70","~$f","~$p"]],"^Y",["^Z",[["~$f","~$p"],["^70","~$f","~$p"]]],"^6S",["^Z",[null,null]]]],"^11","^2E","^6","promesa/core.cljc","^:",13,"^6N",["^ ","^6O",false,"^6P",3,"^6Q",3,"^6R",[["~$f","~$p"],["^70","~$f","~$p"]],"^Y",["^Z",[["~$f","~$p"],["^70","~$f","~$p"]]],"^6S",["^Z",[null,null]]],"^6R",[["~$f","~$p"],["^70","~$f","~$p"]],"^6T",null,"^6P",3,"^6S",["^Z",[null,null]],"^8",1,"^6O",false,"^6U",[["^ ","^6P",2,"^6O",false,"^6V","^6W"],["^ ","^6P",3,"^6O",false,"^6V","^6W"]],"^7",191,"^9",191,"^6Q",3,"^6X",true,"^Y",["^Z",[["~$f","~$p"],["^70","~$f","~$p"]]],"^10","Chains a computation `f` (function) to be executed when the promise\n  `p` is successfully resolved. always expecting that `f` returns a\n  promise that will be automatically unwrapped.\n\n  This is just a stricter version of `then` with reversed arguments in\n  the same way as `map`.\n\n  This is designed to be used with `->>`."],"~$cancelled?",["^ ","^6K",null,"^5",["^ ","^6","promesa/core.cljc","^7",356,"^8",7,"^9",356,"^:",17,"^Y",["^Z",["^6L",["^Z",[["~$v"]]]]],"^10","Return true if `v` is a cancelled promise."],"^11","^3B","^6","promesa/core.cljc","^:",17,"^6R",["^Z",[["~$v"]]],"^6T",null,"^6S",["^Z",[null,null]],"^8",1,"^6O",false,"^7",356,"^6Z","^6W","^9",356,"^6Q",1,"^6X",true,"^Y",["^Z",["^6L",["^Z",[["~$v"]]]]],"^10","Return true if `v` is a cancelled promise."],"~$bind",["^ ","^6K",null,"^5",["^ ","^6","promesa/core.cljc","^7",161,"^8",7,"^9",161,"^:",11,"^Y",["^Z",["^6L",["^Z",[["~$p","~$f"],["~$p","~$f","^70"]]]]],"^6N",["^ ","^6O",false,"^6P",3,"^6Q",3,"^6R",[["~$p","~$f"],["~$p","~$f","^70"]],"^Y",["^Z",[["~$p","~$f"],["~$p","~$f","^70"]]],"^6S",["^Z",[null,null]]]],"^11","^33","^6","promesa/core.cljc","^:",11,"^6N",["^ ","^6O",false,"^6P",3,"^6Q",3,"^6R",[["~$p","~$f"],["~$p","~$f","^70"]],"^Y",["^Z",[["~$p","~$f"],["~$p","~$f","^70"]]],"^6S",["^Z",[null,null]]],"^6R",[["~$p","~$f"],["~$p","~$f","^70"]],"^6T",null,"^6P",3,"^6S",["^Z",[null,null]],"^8",1,"^6O",false,"^6U",[["^ ","^6P",2,"^6O",false,"^6V","^6W"],["^ ","^6P",3,"^6O",false,"^6V","^6W"]],"^7",161,"^9",161,"^6Q",3,"^6X",true,"^Y",["^Z",[["~$p","~$f"],["~$p","~$f","^70"]]]],"~$resolve!",["^ ","^6K",null,"^5",["^ ","^6","promesa/core.cljc","^7",363,"^8",7,"^9",363,"^:",15,"^Y",["^Z",["^6L",["^Z",[["~$o"],["~$o","~$v"]]]]],"^10","Resolve a completable promise with a value.","^6N",["^ ","^6O",false,"^6P",2,"^6Q",2,"^6R",[["~$o"],["~$o","~$v"]],"^Y",["^Z",[["~$o"],["~$o","~$v"]]],"^6S",["^Z",[null,null]]]],"^11","^2A","^6","promesa/core.cljc","^:",15,"^6N",["^ ","^6O",false,"^6P",2,"^6Q",2,"^6R",[["~$o"],["~$o","~$v"]],"^Y",["^Z",[["~$o"],["~$o","~$v"]]],"^6S",["^Z",[null,null]]],"^6R",[["~$o"],["~$o","~$v"]],"^6T",null,"^6P",2,"^6S",["^Z",[null,null]],"^8",1,"^6O",false,"^6U",[["^ ","^6P",1,"^6O",false,"^6V","^6W"],["^ ","^6P",2,"^6O",false,"^6V","^6W"]],"^7",363,"^9",363,"^6Q",2,"^6X",true,"^Y",["^Z",[["~$o"],["~$o","~$v"]]],"^10","Resolve a completable promise with a value."],"^6W",["^ ","^6K",null,"^5",["^ ","^6","promesa/core.cljc","^7",311,"^8",7,"^9",311,"^:",10,"^Y",["^Z",["^6L",["^Z",[["~$promises"],["^75","~$default"]]]]],"^10","Given an array of promises, return a promise that is fulfilled when\n  first one item in the array is fulfilled.","^6N",["^ ","^6O",false,"^6P",2,"^6Q",2,"^6R",[["^75"],["^75","^76"]],"^Y",["^Z",[["^75"],["^75","^76"]]],"^6S",["^Z",[null,null]]]],"^11","^42","^6","promesa/core.cljc","^:",10,"^6N",["^ ","^6O",false,"^6P",2,"^6Q",2,"^6R",[["^75"],["^75","^76"]],"^Y",["^Z",[["^75"],["^75","^76"]]],"^6S",["^Z",[null,null]]],"^6R",[["^75"],["^75","^76"]],"^6T",null,"^6P",2,"^6S",["^Z",[null,null]],"^8",1,"^6O",false,"^6U",[["^ ","^6P",1,"^6O",false,"^6V","^6W"],["^ ","^6P",2,"^6O",false,"^6V","^3C"]],"^7",311,"^9",311,"^6Q",2,"^6X",true,"^Y",["^Z",[["^75"],["^75","^76"]]],"^10","Given an array of promises, return a promise that is fulfilled when\n  first one item in the array is fulfilled."],"~$finally",["^ ","^6K",null,"^5",["^ ","^6","promesa/core.cljc","^7",227,"^8",7,"^9",227,"^:",14,"^Y",["^Z",["^6L",["^Z",[["~$p","~$f"],["~$p","~$f","^70"]]]]],"^10","Attach a potentially side-effectful handler to promise that will be\n  executed independently if promise is resolved or rejected.\n\n  Returns the original promise and the return value of `f` function is\n  ignored.","^6N",["^ ","^6O",false,"^6P",3,"^6Q",3,"^6R",[["~$p","~$f"],["~$p","~$f","^70"]],"^Y",["^Z",[["~$p","~$f"],["~$p","~$f","^70"]]],"^6S",["^Z",[null,null]]]],"^11","^3X","^6","promesa/core.cljc","^:",14,"^6N",["^ ","^6O",false,"^6P",3,"^6Q",3,"^6R",[["~$p","~$f"],["~$p","~$f","^70"]],"^Y",["^Z",[["~$p","~$f"],["~$p","~$f","^70"]]],"^6S",["^Z",[null,null]]],"^6R",[["~$p","~$f"],["~$p","~$f","^70"]],"^6T",null,"^6P",3,"^6S",["^Z",[null,null]],"^8",1,"^6O",false,"^6U",[["^ ","^6P",2,"^6O",false,"^6V","^6W"],["^ ","^6P",3,"^6O",false,"^6V","^6W"]],"^7",227,"^9",227,"^6Q",3,"^6X",true,"^Y",["^Z",[["~$p","~$f"],["~$p","~$f","^70"]]],"^10","Attach a potentially side-effectful handler to promise that will be\n  executed independently if promise is resolved or rejected.\n\n  Returns the original promise and the return value of `f` function is\n  ignored."],"~$then'",["^ ","^6K",null,"^5",["^ ","^6","promesa/core.cljc","^7",167,"^8",7,"^9",167,"^:",12,"^Y",["^Z",["^6L",["^Z",[["~$p","~$f"],["~$p","~$f","^70"]]]]],"^10","Chains a computation `f` (function) to be executed when the promise\n  `p` is successfully resolved.\n\n  The computation will be executed in the calling thread by default;\n  you also can provide a custom executor.\n\n  Don't perform flatten on the result.","^6N",["^ ","^6O",false,"^6P",3,"^6Q",3,"^6R",[["~$p","~$f"],["~$p","~$f","^70"]],"^Y",["^Z",[["~$p","~$f"],["~$p","~$f","^70"]]],"^6S",["^Z",[null,null]]]],"^11","^39","^6","promesa/core.cljc","^:",12,"^6N",["^ ","^6O",false,"^6P",3,"^6Q",3,"^6R",[["~$p","~$f"],["~$p","~$f","^70"]],"^Y",["^Z",[["~$p","~$f"],["~$p","~$f","^70"]]],"^6S",["^Z",[null,null]]],"^6R",[["~$p","~$f"],["~$p","~$f","^70"]],"^6T",null,"^6P",3,"^6S",["^Z",[null,null]],"^8",1,"^6O",false,"^6U",[["^ ","^6P",2,"^6O",false,"^6V","^6W"],["^ ","^6P",3,"^6O",false,"^6V","^6W"]],"^7",167,"^9",167,"^6Q",3,"^6X",true,"^Y",["^Z",[["~$p","~$f"],["~$p","~$f","^70"]]],"^10","Chains a computation `f` (function) to be executed when the promise\n  `p` is successfully resolved.\n\n  The computation will be executed in the calling thread by default;\n  you also can provide a custom executor.\n\n  Don't perform flatten on the result."],"~$chain'",["^ ","^6K",null,"^5",["^ ","^6","promesa/core.cljc","^7",212,"^8",7,"^9",212,"^:",13,"^Y",["^Z",["^6L",["^Z",[["~$p","~$f"],["~$p","~$f","~$&","~$fs"]]]]],"^10","Chain variable number of computations to be executed serially. Unlike\n  `chain` does not flattens the return value of each step (probably\n  this is more performant than `chain`).","^6N",["^ ","^6O",true,"^6P",2,"^6Q",2,"^6R",[["~$p","~$f"]],"^Y",["^Z",[["~$p","~$f"],["~$p","~$f","~$&","^7:"]]],"^6S",["^Z",[null,null]]]],"^11","^3?","^6","promesa/core.cljc","^:",13,"^6N",["^ ","^6O",true,"^6P",2,"^6Q",2,"^6R",[["~$p","~$f"]],"^Y",["^Z",[["~$p","~$f"],["~$p","~$f","~$&","^7:"]]],"^6S",["^Z",[null,null]]],"^6R",[["~$p","~$f"]],"^6T",null,"^6P",2,"^6S",["^Z",[null,null]],"^8",1,"^6O",true,"^6U",[["^ ","^6P",2,"^6O",false,"^6V","^6W"],["^ ","^6P",2,"^6O",true,"^6V",["^F",[null,"^6W"]]]],"^7",212,"^9",212,"^6Q",2,"^6X",true,"^Y",["^Z",[["~$p","~$f"],["~$p","~$f","~$&","^7:"]]],"^10","Chain variable number of computations to be executed serially. Unlike\n  `chain` does not flattens the return value of each step (probably\n  this is more performant than `chain`)."],"~$wrap",["^ ","^6K",null,"^5",["^ ","^6","promesa/core.cljc","^7",70,"^8",7,"^9",70,"^:",11,"^Y",["^Z",["^6L",["^Z",[["~$v"]]]]],"^10","A convenience alias for `promise` coercion function that only accepts\n  a single argument."],"^11","^32","^6","promesa/core.cljc","^:",11,"^6R",["^Z",[["~$v"]]],"^6T",null,"^6S",["^Z",[null,null]],"^8",1,"^6O",false,"^7",70,"^6Z","^6W","^9",70,"^6Q",1,"^6X",true,"^Y",["^Z",["^6L",["^Z",[["~$v"]]]]],"^10","A convenience alias for `promise` coercion function that only accepts\n  a single argument."],"~$promisify",["^ ","^6K",null,"^5",["^ ","^6","promesa/core.cljc","^7",375,"^8",7,"^9",375,"^:",16,"^Y",["^Z",["^6L",["^Z",[["~$callable"]]]]],"^10","Given a function that accepts a callback as the last argument return other\n  function that returns a promise. Callback is expected to take single\n  parameter (result of a computation)."],"^11","^2C","^6","promesa/core.cljc","^:",16,"^6R",["^Z",[["^7="]]],"^6T",null,"^6S",["^Z",[null,null]],"^8",1,"^6O",false,"^7",375,"^6Z","~$function","^9",375,"^6Q",1,"^6X",true,"^Y",["^Z",["^6L",["^Z",[["^7="]]]]],"^10","Given a function that accepts a callback as the last argument return other\n  function that returns a promise. Callback is expected to take single\n  parameter (result of a computation)."],"~$rejected",["^ ","^6K",null,"^5",["^ ","^6","promesa/core.cljc","^7",49,"^8",7,"^9",49,"^:",15,"^Y",["^Z",["^6L",["^Z",[["~$v"]]]]],"^10","Return a rejected promise with provided reason."],"^11","^2W","^6","promesa/core.cljc","^:",15,"^6R",["^Z",[["~$v"]]],"^6T",null,"^6S",["^Z",[null,null]],"^8",1,"^6O",false,"^7",49,"^6Z","^6W","^9",49,"^6Q",1,"^6X",true,"^Y",["^Z",["^6L",["^Z",[["~$v"]]]]],"^10","Return a rejected promise with provided reason."],"^Q",["^ ","^6K",null,"^5",["^ ","^6","promesa/core.cljc","^7",59,"^8",7,"^9",59,"^:",14,"^Y",["^Z",["^6L",["^Z",[["~$v"],["~$v","^70"]]]]],"^10","The coerce based promise constructor. Creates a appropriate promise\n  instance depending on the provided value.\n\n  If an executor is provided, it will be used to resolve this\n  promise.","^6N",["^ ","^6O",false,"^6P",2,"^6Q",2,"^6R",[["~$v"],["~$v","^70"]],"^Y",["^Z",[["~$v"],["~$v","^70"]]],"^6S",["^Z",[null,null]]]],"^11","^2@","^6","promesa/core.cljc","^:",14,"^6N",["^ ","^6O",false,"^6P",2,"^6Q",2,"^6R",[["~$v"],["~$v","^70"]],"^Y",["^Z",[["~$v"],["~$v","^70"]]],"^6S",["^Z",[null,null]]],"^6R",[["~$v"],["~$v","^70"]],"^6T",null,"^6P",2,"^6S",["^Z",[null,null]],"^8",1,"^6O",false,"^6U",[["^ ","^6P",1,"^6O",false,"^6V","^6W"],["^ ","^6P",2,"^6O",false,"^6V","^6W"]],"^7",59,"^9",59,"^6Q",2,"^6X",true,"^Y",["^Z",[["~$v"],["~$v","^70"]]],"^10","The coerce based promise constructor. Creates a appropriate promise\n  instance depending on the provided value.\n\n  If an executor is provided, it will be used to resolve this\n  promise."],"~$create",["^ ","^6K",null,"^5",["^ ","^6","promesa/core.cljc","^7",76,"^8",7,"^9",76,"^:",13,"^Y",["^Z",["^6L",["^Z",[["~$f"],["~$f","^70"]]]]],"^10","Create a promise instance from a factory function. If an executor is\n  provided, the factory will be executed in the provided executor.\n\n  A factory function looks like `(fn [resolve reject] (resolve 1))`.","^6N",["^ ","^6O",false,"^6P",2,"^6Q",2,"^6R",[["~$f"],["~$f","^70"]],"^Y",["^Z",[["~$f"],["~$f","^70"]]],"^6S",["^Z",[null,null]]]],"^11","^3S","^6","promesa/core.cljc","^:",13,"^6N",["^ ","^6O",false,"^6P",2,"^6Q",2,"^6R",[["~$f"],["~$f","^70"]],"^Y",["^Z",[["~$f"],["~$f","^70"]]],"^6S",["^Z",[null,null]]],"^6R",[["~$f"],["~$f","^70"]],"^6T",null,"^6P",2,"^6S",["^Z",[null,null]],"^8",1,"^6O",false,"^6U",[["^ ","^6P",1,"^6O",false,"^6V","^3C"],["^ ","^6P",2,"^6O",false,"^6V","^3C"]],"^7",76,"^9",76,"^6Q",2,"^6X",true,"^Y",["^Z",[["~$f"],["~$f","^70"]]],"^10","Create a promise instance from a factory function. If an executor is\n  provided, the factory will be executed in the provided executor.\n\n  A factory function looks like `(fn [resolve reject] (resolve 1))`."],"~$race",["^ ","^6K",null,"^5",["^ ","^6","promesa/core.cljc","^7",305,"^8",7,"^9",305,"^:",11,"^Y",["^Z",["^6L",["^Z",[["^75"]]]]]],"^11","^3R","^6","promesa/core.cljc","^:",11,"^6R",["^Z",[["^75"]]],"^6T",null,"^6S",["^Z",[null,null]],"^8",1,"^6O",false,"^7",305,"^6Z","^6W","^9",305,"^6Q",1,"^6X",true,"^Y",["^Z",["^6L",["^Z",[["^75"]]]]]],"~$cancel!",["^ ","^6K",null,"^5",["^ ","^6","promesa/core.cljc","^7",350,"^8",7,"^9",350,"^:",14,"^Y",["^Z",["^6L",["^Z",[["~$p"]]]]],"^10","Cancel the promise."],"^11","^3W","^6","promesa/core.cljc","^:",14,"^6R",["^Z",[["~$p"]]],"^6T",null,"^6S",["^Z",[null,null]],"^8",1,"^6O",false,"^7",350,"^9",350,"^6Q",1,"^6X",true,"^Y",["^Z",["^6L",["^Z",[["~$p"]]]]],"^10","Cancel the promise."],"~$thenable?",["^ ","^6K",null,"^5",["^ ","^6","promesa/core.cljc","^7",114,"^8",10,"^9",114,"^:",19,"^Y",["^Z",["^6L",["^Z",[["~$v"]]]]],"^10","Returns true if `v` is a promise like object."],"^11","^3V","^6","promesa/core.cljc","^:",19,"^6R",["^Z",[["~$v"]]],"^6T",null,"^6S",["^Z",[null,null]],"^8",4,"^6O",false,"^7",114,"^6Z","^6[","^9",114,"^6Q",1,"^6X",true,"^Y",["^Z",["^6L",["^Z",[["~$v"]]]]],"^10","Returns true if `v` is a promise like object."],"~$TimeoutException",["^ ","^6K",null,"^5",["^ ","^6","promesa/core.cljc","^7",390,"^8",6,"^9",390,"^:",22,"~:jsdoc",["@constructor"],"^Y",["^Z",["^6L",["^Z",[["~$message"]]]]]],"^11","^30","^6","promesa/core.cljc","^:",22,"^6R",["^Z",[["^7F"]]],"^6T",null,"^6S",["^Z",[null,null]],"^8",4,"^6O",false,"^7",389,"^6Z","^6W","^9",390,"^6Q",1,"^6X",true,"^Y",["^Z",["^6L",["^Z",[["^7F"]]]]],"^7E",["@constructor"]],"~$done?",["^ ","^5",["^ ","^6","promesa/core.cljc","^7",141,"^8",6,"^9",141,"^:",11],"^11","^3Z","^6","promesa/core.cljc","^:",11,"^8",1,"^7",141,"^9",141,"^6V","^7>","^10","Returns true if promise `p` is already done."],"~$err",["^ ","^11","^4C","^6","promesa/core.cljc","^7",275,"^8",1,"^9",275,"^:",9,"^5",["^ ","^6","promesa/core.cljc","^7",275,"^8",6,"^9",275,"^:",9],"^10","A short alias for `error` function."],"~$catch'",["^ ","^6K",null,"^5",["^ ","^6","promesa/core.cljc","^7",254,"^8",7,"^9",254,"^:",13,"^Y",["^Z",["^6L",["^Z",[["~$p","~$f"],["~$p","~$pred-or-type","~$f"]]]]],"^10","Executes `f` when the promise `p` is rejected. Returns a promise\n  resolved with the return value of `f` function handler.","^6N",["^ ","^6O",false,"^6P",3,"^6Q",3,"^6R",[["~$p","~$f"],["~$p","^7J","~$f"]],"^Y",["^Z",[["~$p","~$f"],["~$p","^7J","~$f"]]],"^6S",["^Z",[null,null]]]],"^11","^3P","^6","promesa/core.cljc","^:",13,"^6N",["^ ","^6O",false,"^6P",3,"^6Q",3,"^6R",[["~$p","~$f"],["~$p","^7J","~$f"]],"^Y",["^Z",[["~$p","~$f"],["~$p","^7J","~$f"]]],"^6S",["^Z",[null,null]]],"^6R",[["~$p","~$f"],["~$p","^7J","~$f"]],"^6T",null,"^6P",3,"^6S",["^Z",[null,null]],"^8",1,"^6O",false,"^6U",[["^ ","^6P",2,"^6O",false,"^6V","^6W"],["^ ","^6P",3,"^6O",false,"^6V","^6W"]],"^7",254,"^9",254,"^6Q",3,"^6X",true,"^Y",["^Z",[["~$p","~$f"],["~$p","^7J","~$f"]]],"^10","Executes `f` when the promise `p` is rejected. Returns a promise\n  resolved with the return value of `f` function handler."],"^R",["^ ","^6K",null,"^5",["^ ","^6","promesa/core.cljc","^7",343,"^8",7,"^9",343,"^:",11,"^Y",["^Z",["^6L",["^Z",[["~$f","~$coll"],["~$f","^7K","^70"]]]]],"^10","A promise aware run! function.","^6N",["^ ","^6O",false,"^6P",3,"^6Q",3,"^6R",[["~$f","^7K"],["~$f","^7K","^70"]],"^Y",["^Z",[["~$f","^7K"],["~$f","^7K","^70"]]],"^6S",["^Z",[null,null]]]],"^11","^2X","^6","promesa/core.cljc","^:",11,"^6N",["^ ","^6O",false,"^6P",3,"^6Q",3,"^6R",[["~$f","^7K"],["~$f","^7K","^70"]],"^Y",["^Z",[["~$f","^7K"],["~$f","^7K","^70"]]],"^6S",["^Z",[null,null]]],"^6R",[["~$f","^7K"],["~$f","^7K","^70"]],"^6T",null,"^6P",3,"^6S",["^Z",[null,null]],"^8",1,"^6O",false,"^6U",[["^ ","^6P",2,"^6O",false,"^6V","^6W"],["^ ","^6P",3,"^6O",false,"^6V",["^F",[null,"^6W"]]]],"^7",343,"^9",343,"^6Q",3,"^6X",true,"^Y",["^Z",[["~$f","^7K"],["~$f","^7K","^70"]]],"^10","A promise aware run! function."],"~$all",["^ ","^6K",null,"^5",["^ ","^6","promesa/core.cljc","^7",279,"^8",7,"^9",279,"^:",10,"^Y",["^Z",["^6L",["^Z",[["^75"]]]]],"^10","Given an array of promises, return a promise\n  that is fulfilled  when all the items in the\n  array are fulfilled.\n\n  Example:\n\n  (-> (all [(promise :first-promise)\n            (promise :second-promise)]\n      (then (fn [[first-result second-result]]))\n       (println (str first-result \", \" second-result)\n\n  Will print out\n  :first-promise, :second-promise.\n\n  If at least one of the promises is rejected, the resulting promise will be\n  rejected."],"^11","^3@","^6","promesa/core.cljc","^:",10,"^6R",["^Z",[["^75"]]],"^6T",null,"^6S",["^Z",[null,null]],"^8",1,"^6O",false,"^7",279,"^6Z","^6W","^9",279,"^6Q",1,"^6X",true,"^Y",["^Z",["^6L",["^Z",[["^75"]]]]],"^10","Given an array of promises, return a promise\n  that is fulfilled  when all the items in the\n  array are fulfilled.\n\n  Example:\n\n  (-> (all [(promise :first-promise)\n            (promise :second-promise)]\n      (then (fn [[first-result second-result]]))\n       (println (str first-result \", \" second-result)\n\n  Will print out\n  :first-promise, :second-promise.\n\n  If at least one of the promises is rejected, the resulting promise will be\n  rejected."],"~$reject!",["^ ","^6K",null,"^5",["^ ","^6","promesa/core.cljc","^7",368,"^8",7,"^9",368,"^:",14,"^Y",["^Z",["^6L",["^Z",[["~$p","~$e"]]]]],"^10","Reject a completable promise with an error."],"^11","^4K","^6","promesa/core.cljc","^:",14,"^6R",["^Z",[["~$p","~$e"]]],"^6T",null,"^6S",["^Z",[null,null]],"^8",1,"^6O",false,"^7",368,"^6Z","^6W","^9",368,"^6Q",2,"^6X",true,"^Y",["^Z",["^6L",["^Z",[["~$p","~$e"]]]]],"^10","Reject a completable promise with an error."],"~$promise?",["^ ","^6K",null,"^5",["^ ","^6","promesa/core.cljc","^7",99,"^8",7,"^9",99,"^:",15,"^Y",["^Z",["^6L",["^Z",[["~$v"]]]]],"^10","Return true if `v` is a promise instance."],"^11","^4A","^6","promesa/core.cljc","^:",15,"^6R",["^Z",[["~$v"]]],"^6T",null,"^6S",["^Z",[null,null]],"^8",1,"^6O",false,"^7",99,"^6Z","^6[","^9",99,"^6Q",1,"^6X",true,"^Y",["^Z",["^6L",["^Z",[["~$v"]]]]],"^10","Return true if `v` is a promise instance."],"~$resolved",["^ ","^6K",null,"^5",["^ ","^6","promesa/core.cljc","^7",44,"^8",7,"^9",44,"^:",15,"^Y",["^Z",["^6L",["^Z",[["~$v"]]]]],"^10","Return a resolved promise with provided value."],"^11","^3D","^6","promesa/core.cljc","^:",15,"^6R",["^Z",[["~$v"]]],"^6T",null,"^6S",["^Z",[null,null]],"^8",1,"^6O",false,"^7",44,"^6Z","^6W","^9",44,"^6Q",1,"^6X",true,"^Y",["^Z",["^6L",["^Z",[["~$v"]]]]],"^10","Return a resolved promise with provided value."],"~$deferred",["^ ","^6K",null,"^5",["^ ","^6","promesa/core.cljc","^7",54,"^8",7,"^9",54,"^:",15,"^Y",["^Z",["^6L",["^Z",[[]]]]],"^10","Creates an empty promise instance."],"^11","^36","^6","promesa/core.cljc","^:",15,"^6R",["^Z",[[]]],"^6T",null,"^6S",["^Z",[null,null]],"^8",1,"^6O",false,"^7",54,"^6Z","^3C","^9",54,"^6Q",0,"^6X",true,"^Y",["^Z",["^6L",["^Z",[[]]]]],"^10","Creates an empty promise instance."],"~$*loop-run-fn*",["^ ","^5",["^ ","^6","promesa/core.cljc","^7",478,"^8",16,"^9",478,"^:",29,"~:dynamic",true],"^11","^4H","^6","promesa/core.cljc","^:",29,"^8",1,"^7R",true,"^7",478,"^9",478,"^6V","^6W"],"~$catch",["^ ","^6K",null,"^5",["^ ","^6","promesa/core.cljc","^7",238,"^8",7,"^9",238,"^:",12,"^Y",["^Z",["^6L",["^Z",[["~$p","~$f"],["~$p","^7J","~$f"]]]]],"^10","Executes `f` when the promise `p` is rejected. Returns a promise\n  resolved with the return value of `f` function handler.","^6N",["^ ","^6O",false,"^6P",3,"^6Q",3,"^6R",[["~$p","~$f"],["~$p","^7J","~$f"]],"^Y",["^Z",[["~$p","~$f"],["~$p","^7J","~$f"]]],"^6S",["^Z",[null,null]]]],"^11","^2J","^6","promesa/core.cljc","^:",12,"^6N",["^ ","^6O",false,"^6P",3,"^6Q",3,"^6R",[["~$p","~$f"],["~$p","^7J","~$f"]],"^Y",["^Z",[["~$p","~$f"],["~$p","^7J","~$f"]]],"^6S",["^Z",[null,null]]],"^6R",[["~$p","~$f"],["~$p","^7J","~$f"]],"^6T",null,"^6P",3,"^6S",["^Z",[null,null]],"^8",1,"^6O",false,"^6U",[["^ ","^6P",2,"^6O",false,"^6V","^6W"],["^ ","^6P",3,"^6O",false,"^6V","^6W"]],"^7",238,"^9",238,"^6Q",3,"^6X",true,"^Y",["^Z",[["~$p","~$f"],["~$p","^7J","~$f"]]],"^10","Executes `f` when the promise `p` is rejected. Returns a promise\n  resolved with the return value of `f` function handler."],"~$chain",["^ ","^6K",null,"^5",["^ ","^6","promesa/core.cljc","^7",205,"^8",7,"^9",205,"^:",12,"^Y",["^Z",["^6L",["^Z",[["~$p","~$f"],["~$p","~$f","~$&","^7:"]]]]],"^10","Chain variable number of computations to be executed\n  serially. Analogous to `then` that accepts variable number of\n  functions.","^6N",["^ ","^6O",true,"^6P",2,"^6Q",2,"^6R",[["~$p","~$f"]],"^Y",["^Z",[["~$p","~$f"],["~$p","~$f","~$&","^7:"]]],"^6S",["^Z",[null,null]]]],"^11","^4>","^6","promesa/core.cljc","^:",12,"^6N",["^ ","^6O",true,"^6P",2,"^6Q",2,"^6R",[["~$p","~$f"]],"^Y",["^Z",[["~$p","~$f"],["~$p","~$f","~$&","^7:"]]],"^6S",["^Z",[null,null]]],"^6R",[["~$p","~$f"]],"^6T",null,"^6P",2,"^6S",["^Z",[null,null]],"^8",1,"^6O",true,"^6U",[["^ ","^6P",2,"^6O",false,"^6V","^6W"],["^ ","^6P",2,"^6O",true,"^6V",["^F",[null,"^6W"]]]],"^7",205,"^9",205,"^6Q",2,"^6X",true,"^Y",["^Z",[["~$p","~$f"],["~$p","~$f","~$&","^7:"]]],"^10","Chain variable number of computations to be executed\n  serially. Analogous to `then` that accepts variable number of\n  functions."],"~$handle",["^ ","^6K",null,"^5",["^ ","^6","promesa/core.cljc","^7",219,"^8",7,"^9",219,"^:",13,"^Y",["^Z",["^6L",["^Z",[["~$p","~$f"],["~$p","~$f","^70"]]]]],"^10","Executes `f` when the promise `p` is resolved or is rejected. Returns\n  a promise resolved with the return value of `f` function.","^6N",["^ ","^6O",false,"^6P",3,"^6Q",3,"^6R",[["~$p","~$f"],["~$p","~$f","^70"]],"^Y",["^Z",[["~$p","~$f"],["~$p","~$f","^70"]]],"^6S",["^Z",[null,null]]]],"^11","^3O","^6","promesa/core.cljc","^:",13,"^6N",["^ ","^6O",false,"^6P",3,"^6Q",3,"^6R",[["~$p","~$f"],["~$p","~$f","^70"]],"^Y",["^Z",[["~$p","~$f"],["~$p","~$f","^70"]]],"^6S",["^Z",[null,null]]],"^6R",[["~$p","~$f"],["~$p","~$f","^70"]],"^6T",null,"^6P",3,"^6S",["^Z",[null,null]],"^8",1,"^6O",false,"^6U",[["^ ","^6P",2,"^6O",false,"^6V","^6W"],["^ ","^6P",3,"^6O",false,"^6V","^6W"]],"^7",219,"^9",219,"^6Q",3,"^6X",true,"^Y",["^Z",[["~$p","~$f"],["~$p","~$f","^70"]]],"^10","Executes `f` when the promise `p` is resolved or is rejected. Returns\n  a promise resolved with the return value of `f` function."],"~$rejected?",["^ ","^6K",null,"^5",["^ ","^6","promesa/core.cljc","^7",126,"^8",7,"^9",126,"^:",16,"^Y",["^Z",["^6L",["^Z",[["~$p"]]]]],"^10","Returns true if promise `p` is already rejected."],"^11","^2U","^6","promesa/core.cljc","^:",16,"^6R",["^Z",[["~$p"]]],"^6T",null,"^6S",["^Z",[null,null]],"^8",1,"^6O",false,"^7",126,"^6Z","^6W","^9",126,"^6Q",1,"^6X",true,"^Y",["^Z",["^6L",["^Z",[["~$p"]]]]],"^10","Returns true if promise `p` is already rejected."],"~$then",["^ ","^6K",null,"^5",["^ ","^6","promesa/core.cljc","^7",147,"^8",7,"^9",147,"^:",11,"^Y",["^Z",["^6L",["^Z",[["~$p","~$f"],["~$p","~$f","^70"]]]]],"^10","Chains a computation `f` (function) to be executed when the promise\n  `p` is successfully resolved.\n\n  The computation will be executed in the calling thread by default;\n  you also can provide a custom executor.\n\n  If the function `f` returns a promise instance, it will be\n  automatically unwrapped.","^6N",["^ ","^6O",false,"^6P",3,"^6Q",3,"^6R",[["~$p","~$f"],["~$p","~$f","^70"]],"^Y",["^Z",[["~$p","~$f"],["~$p","~$f","^70"]]],"^6S",["^Z",[null,null]]]],"^11","^41","^6","promesa/core.cljc","^:",11,"^6N",["^ ","^6O",false,"^6P",3,"^6Q",3,"^6R",[["~$p","~$f"],["~$p","~$f","^70"]],"^Y",["^Z",[["~$p","~$f"],["~$p","~$f","^70"]]],"^6S",["^Z",[null,null]]],"^6R",[["~$p","~$f"],["~$p","~$f","^70"]],"^6T",null,"^6P",3,"^6S",["^Z",[null,null]],"^8",1,"^6O",false,"^6U",[["^ ","^6P",2,"^6O",false,"^6V","^6W"],["^ ","^6P",3,"^6O",false,"^6V","^6W"]],"^7",147,"^9",147,"^6Q",3,"^6X",true,"^Y",["^Z",[["~$p","~$f"],["~$p","~$f","^70"]]],"^10","Chains a computation `f` (function) to be executed when the promise\n  `p` is successfully resolved.\n\n  The computation will be executed in the calling thread by default;\n  you also can provide a custom executor.\n\n  If the function `f` returns a promise instance, it will be\n  automatically unwrapped."],"~$extract",["^ ","^6K",null,"^5",["^ ","^6","promesa/core.cljc","^7",136,"^8",7,"^9",136,"^:",14,"^Y",["^Z",["^6L",["^Z",[["~$p"]]]]],"^10","Returns the current promise value."],"^11","^2P","^6","promesa/core.cljc","^:",14,"^6R",["^Z",[["~$p"]]],"^6T",null,"^6S",["^Z",[null,null]],"^8",1,"^6O",false,"^7",136,"^6Z","^6W","^9",136,"^6Q",1,"^6X",true,"^Y",["^Z",["^6L",["^Z",[["~$p"]]]]],"^10","Returns the current promise value."],"~$error",["^ ","^6K",null,"^5",["^ ","^6","promesa/core.cljc","^7",270,"^8",7,"^9",270,"^:",12,"^Y",["^Z",["^6L",["^Z",[["~$f","~$p"],["~$f","~$type","~$p"]]]]],"^10","Same as `catch` but with parameters inverted.","^6N",["^ ","^6O",false,"^6P",3,"^6Q",3,"^6R",[["~$f","~$p"],["~$f","^7Z","~$p"]],"^Y",["^Z",[["~$f","~$p"],["~$f","^7Z","~$p"]]],"^6S",["^Z",[null,null]]]],"^11","^3Q","^6","promesa/core.cljc","^:",12,"^6N",["^ ","^6O",false,"^6P",3,"^6Q",3,"^6R",[["~$f","~$p"],["~$f","^7Z","~$p"]],"^Y",["^Z",[["~$f","~$p"],["~$f","^7Z","~$p"]]],"^6S",["^Z",[null,null]]],"^6R",[["~$f","~$p"],["~$f","^7Z","~$p"]],"^6T",null,"^6P",3,"^6S",["^Z",[null,null]],"^8",1,"^6O",false,"^6U",[["^ ","^6P",2,"^6O",false,"^6V","^6W"],["^ ","^6P",3,"^6O",false,"^6V","^6W"]],"^7",270,"^9",270,"^6Q",3,"^6X",true,"^Y",["^Z",[["~$f","~$p"],["~$f","^7Z","~$p"]]],"^10","Same as `catch` but with parameters inverted."],"~$pending?",["^ ","^6K",null,"^5",["^ ","^6","promesa/core.cljc","^7",131,"^8",7,"^9",131,"^:",15,"^Y",["^Z",["^6L",["^Z",[["~$p"]]]]],"^10","Returns true if promise `p` is stil pending."],"^11","^3H","^6","promesa/core.cljc","^:",15,"^6R",["^Z",[["~$p"]]],"^6T",null,"^6S",["^Z",[null,null]],"^8",1,"^6O",false,"^7",131,"^6Z","^6W","^9",131,"^6Q",1,"^6X",true,"^Y",["^Z",["^6L",["^Z",[["~$p"]]]]],"^10","Returns true if promise `p` is stil pending."]],"^1T",["^ ","^14","^14","^C","^C","^B","^C","~$c","^C"],"~:cljs.analyzer/constants",["^ ","^1R",["^F",["~:promesa.core/default","~:else","~:resolved","~:counter","~:rejections"]],"~:order",["^81","^83","^84","^85","^82"]],"^1[",["^ ","^1S",["^F",[]],"^1T",["^F",[]]],"^20",["^ "],"^21",["^1O","^C","^1M","^C","^1Q","^1L"]],"^13","^14","~:ns-specs",["^ "],"~:ns-spec-vars",["^F",[]],"~:compiler-options",["^4M",[["^89","~:static-fns"],true,["^89","~:shadow-tweaks"],null,["^89","~:source-map-inline"],null,["^89","~:elide-asserts"],false,["^89","~:optimize-constants"],null,["^89","^26"],null,["^89","~:external-config"],null,["^89","~:tooling-config"],null,["^89","~:emit-constants"],null,["^89","~:load-tests"],null,["^89","~:form-size-threshold"],null,["^89","~:global-goog-object&array"],null,["^89","~:data-readers"],null,["^89","~:infer-externs"],"~:auto",["^89","^28"],null,["~:js-options","~:js-provider"],"~:shadow",["~:mode"],"~:dev",["^89","~:fn-invoke-direct"],null,["^89","~:source-map"],"/dev/null"]]]