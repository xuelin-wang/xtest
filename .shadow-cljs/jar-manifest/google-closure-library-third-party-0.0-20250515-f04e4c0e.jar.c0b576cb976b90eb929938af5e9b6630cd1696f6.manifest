["^ ","~:resources",[["^ ","~:cache-key",["c0b576cb976b90eb929938af5e9b6630cd1696f6"],"~:goog-provides",["~#set",["~$goog.dom.query"]],"~:output-name","goog.dojo.dom.query.js","~:resource-id",["~:shadow.build.classpath/resource","goog/dojo/dom/query.js"],"~:resource-name","goog/dojo/dom/query.js","~:type","~:goog","~:source","// Copyright 2005-2009, The Dojo Foundation\n// Modifications Copyright 2008 The Closure Library Authors.\n// All Rights Reserved.\n\n/**\n * @license Portions of this code are from the Dojo Toolkit, received by\n * The Closure Library Authors under the BSD license. All other code is\n * Copyright 2005-2009 The Closure Library Authors. All Rights Reserved.\n\nThe \"New\" BSD License:\n\nCopyright (c) 2005-2009, The Dojo Foundation\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n  * Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n  * Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n  * Neither the name of the Dojo Foundation nor the names of its contributors\n    may be used to endorse or promote products derived from this software\n    without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE\nFOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\nCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/**\n * @fileoverview This code was ported from the Dojo Toolkit\n   http://dojotoolkit.org and modified slightly for Closure.\n *\n *  goog.dom.query is a relatively full-featured CSS3 query function. It is\n *  designed to take any valid CSS3 selector and return the nodes matching\n *  the selector. To do this quickly, it processes queries in several\n *  steps, applying caching where profitable.\n *    The steps (roughly in reverse order of the way they appear in the code):\n *    1.) check to see if we already have a \"query dispatcher\"\n *      - if so, use that with the given parameterization. Skip to step 4.\n *    2.) attempt to determine which branch to dispatch the query to:\n *      - JS (optimized DOM iteration)\n *      - native (FF3.1, Safari 3.2+, Chrome, some IE 8 doctypes). If native,\n *        skip to step 4, using a stub dispatcher for QSA queries.\n *    3.) tokenize and convert to executable \"query dispatcher\"\n *        assembled as a chain of \"yes/no\" test functions pertaining to\n *        a section of a simple query statement (\".blah:nth-child(odd)\"\n *        but not \"div div\", which is 2 simple statements).\n *    4.) the resulting query dispatcher is called in the passed scope\n *        (by default the top-level document)\n *      - for DOM queries, this results in a recursive, top-down\n *        evaluation of nodes based on each simple query section\n *      - querySelectorAll is used instead of DOM where possible. If a query\n *        fails in this mode, it is re-run against the DOM evaluator and all\n *        future queries using the same selector evaluate against the DOM branch\n *        too.\n *    5.) matched nodes are pruned to ensure they are unique\n * @deprecated This is an all-software query selector. When developing for\n *     recent browsers, use document.querySelector. See information at\n *     http://caniuse.com/queryselector and\n *     https://developer.mozilla.org/en-US/docs/DOM/Document.querySelector .\n */\n\ngoog.provide('goog.dom.query');\n\ngoog.require('goog.array');\ngoog.require('goog.dom');\ngoog.require('goog.functions');\ngoog.require('goog.string');\ngoog.require('goog.userAgent');\n\n/**\n   * Returns nodes which match the given CSS3 selector, searching the\n   * entire document by default but optionally taking a node to scope\n   * the search by.\n   *\n   * dojo.query() is the swiss army knife of DOM node manipulation in\n   * Dojo. Much like Prototype's \"$$\" (bling-bling) function or JQuery's\n   * \"$\" function, dojo.query provides robust, high-performance\n   * CSS-based node selector support with the option of scoping searches\n   * to a particular sub-tree of a document.\n   *\n   * Supported Selectors:\n   * --------------------\n   *\n   * dojo.query() supports a rich set of CSS3 selectors, including:\n   *\n   *   * class selectors (e.g., `.foo`)\n   *   * node type selectors like `span`\n   *   * ` ` descendant selectors\n   *   * `>` child element selectors\n   *   * `#foo` style ID selectors\n   *   * `*` universal selector\n   *   * `~`, the immediately preceded-by sibling selector\n   *   * `+`, the preceded-by sibling selector\n   *   * attribute queries:\n   *      * `[foo]` attribute presence selector\n   *      * `[foo='bar']` attribute value exact match\n   *      * `[foo~='bar']` attribute value list item match\n   *      * `[foo^='bar']` attribute start match\n   *      * `[foo$='bar']` attribute end match\n   *      * `[foo*='bar']` attribute substring match\n   *   * `:first-child`, `:last-child` positional selectors\n   *   * `:empty` content empty selector\n   *   * `:empty` content empty selector\n   *   * `:nth-child(n)`, `:nth-child(2n+1)` style positional calculations\n   *   * `:nth-child(even)`, `:nth-child(odd)` positional selectors\n   *   * `:not(...)` negation pseudo selectors\n   *\n   * Any legal combination of these selectors will work with\n   * `dojo.query()`, including compound selectors (\",\" delimited).\n   * Very complex and useful searches can be constructed with this\n   * palette of selectors.\n   *\n   * Unsupported Selectors:\n   * ----------------------\n   *\n   * While dojo.query handles many CSS3 selectors, some fall outside of\n   * what's reasonable for a programmatic node querying engine to\n   * handle. Currently unsupported selectors include:\n   *\n   *   * namespace-differentiated selectors of any form\n   *   * all `::` pseudo-element selectors\n   *   * certain pseudo-selectors which don't get a lot of day-to-day use:\n   *      * `:root`, `:lang()`, `:target`, `:focus`\n   *   * all visual and state selectors:\n   *      * `:root`, `:active`, `:hover`, `:visited`, `:link`,\n   *       `:enabled`, `:disabled`, `:checked`\n   *   * `:*-of-type` pseudo selectors\n   *\n   * dojo.query and XML Documents:\n   * -----------------------------\n   *\n   * `dojo.query` currently only supports searching XML documents\n   * whose tags and attributes are 100% lower-case. This is a known\n   * limitation and will [be addressed soon]\n   * (http://trac.dojotoolkit.org/ticket/3866)\n   *\n   * Non-selector Queries:\n   * ---------------------\n   *\n   * If something other than a String is passed for the query,\n   * `dojo.query` will return a new array constructed from\n   * that parameter alone and all further processing will stop. This\n   * means that if you have a reference to a node or array or nodes, you\n   * can quickly construct a new array of nodes from the original by\n   * calling `dojo.query(node)` or `dojo.query(array)`.\n   *\n   * __Example:__ search the entire document for elements with the class \"foo\":\n   *\n   *    dojo.query(\".foo\");\n   *\n   * these elements will match:\n   *\n   *    <span class=\"foo\"></span>\n   *    <span class=\"foo bar\"></span>\n   *    <p class=\"thud foo\"></p>\n   *\n   * __Example:__ search the entire document for elements with the classes \"foo\"\n   * _and_ \"bar\":\n   *\n   *    dojo.query(\".foo.bar\");\n   *\n   * these elements will match:\n   *\n   *    <span class=\"foo bar\"></span>\n   *\n   * while these will not:\n   *\n   *    <span class=\"foo\"></span>\n   *    <p class=\"thud foo\"></p>\n   *\n   * __Example:__ find `<span>` elements which are descendants of paragraphs and\n   * which have a \"highlighted\" class:\n   *\n   *    dojo.query(\"p span.highlighted\");\n   *\n   * the innermost span in this fragment matches:\n   *\n   *    <p class=\"foo\">\n   *      <span>...\n   *        <span class=\"highlighted foo bar\">...</span>\n   *      </span>\n   *    </p>\n   *\n   * __Example:__ find all odd table rows inside of the table `#tabular_data`,\n   * using the `>` (direct child) selector to avoid affecting any nested tables:\n   *\n   *    dojo.query(\"#tabular_data > tbody > tr:nth-child(odd)\");\n   *\n   * @param {string|Array} query The CSS3 expression to match against.\n   *     For details on the syntax of CSS3 selectors, see\n   *     http://www.w3.org/TR/css3-selectors/#selectors.\n   * @param {(string|Node)=} opt_root A Node (or node id) to scope the search\n   *     from (optional).\n   * @return { {length: number} } The elements that matched the query.\n   *\n   * @deprecated This is an all-software query selector. Use\n   *     document.querySelector. See\n   *     https://developer.mozilla.org/en-US/docs/DOM/Document.querySelector .\n   */\ngoog.dom.query = (function() {\n  ////////////////////////////////////////////////////////////////////////\n  // Global utilities\n  ////////////////////////////////////////////////////////////////////////\n\n  var cssCaseBug = (goog.userAgent.WEBKIT &&\n                     ((goog.dom.getDocument().compatMode) == 'BackCompat')\n                   );\n\n  var legacyIE = goog.userAgent.IE && !goog.userAgent.isVersionOrHigher('9');\n\n  // On browsers that support the \"children\" collection we can avoid a lot of\n  // iteration on chaff (non-element) nodes.\n  var childNodesName =\n      goog.dom.getDocument().firstChild['children'] ? 'children' : 'childNodes';\n\n  var specials = '>~+';\n\n  // Global thunk to determine whether we should treat the current query as\n  // case sensitive or not. This switch is flipped by the query evaluator based\n  // on the document passed as the context to search.\n  var caseSensitive = false;\n\n\n  ////////////////////////////////////////////////////////////////////////\n  // Tokenizer\n  ////////////////////////////////////////////////////////////////////////\n\n  var getQueryParts = function(query) {\n    //  summary:\n    //    state machine for query tokenization\n    //  description:\n    //    instead of using a brittle and slow regex-based CSS parser,\n    //    dojo.query implements an AST-style query representation. This\n    //    representation is only generated once per query. For example,\n    //    the same query run multiple times or under different root nodes\n    //    does not re-parse the selector expression but instead uses the\n    //    cached data structure. The state machine implemented here\n    //    terminates on the last \" \" (space) character and returns an\n    //    ordered array of query component structures (or \"parts\"). Each\n    //    part represents an operator or a simple CSS filtering\n    //    expression. The structure for parts is documented in the code\n    //    below.\n\n\n    // NOTE:\n    //    this code is designed to run fast and compress well. Sacrifices\n    //    to readability and maintainability have been made.\n    if (specials.indexOf(query.slice(-1)) >= 0) {\n      // If we end with a \">\", \"+\", or \"~\", that means we're implicitly\n      // searching all children, so make it explicit.\n      query += ' * ';\n    } else {\n      // if you have not provided a terminator, one will be provided for\n      // you...\n      query += ' ';\n    }\n\n    var ts = function(/*Integer*/ s, /*Integer*/ e) {\n      // trim and slice.\n\n      // take an index to start a string slice from and an end position\n      // and return a trimmed copy of that sub-string\n      return goog.string.trim(query.slice(s, e));\n    };\n\n    // The overall data graph of the full query, as represented by queryPart\n    // objects.\n    var queryParts = [];\n\n\n    // state keeping vars\n    var inBrackets = -1,\n        inParens = -1,\n        inMatchFor = -1,\n        inPseudo = -1,\n        inClass = -1,\n        inId = -1,\n        inTag = -1,\n        lc = '',\n        cc = '',\n        pStart;\n\n    // iteration vars\n    var x = 0, // index in the query\n        ql = query.length,\n        currentPart = null, // data structure representing the entire clause\n        cp = null; // the current pseudo or attr matcher\n\n    // several temporary variables are assigned to this structure during a\n    // potential sub-expression match:\n    //    attr:\n    //      a string representing the current full attribute match in a\n    //      bracket expression\n    //    type:\n    //      if there's an operator in a bracket expression, this is\n    //      used to keep track of it\n    //    value:\n    //      the internals of parenthetical expression for a pseudo. for\n    //      :nth-child(2n+1), value might be '2n+1'\n\n    var endTag = function() {\n      // called when the tokenizer hits the end of a particular tag name.\n      // Re-sets state variables for tag matching and sets up the matcher\n      // to handle the next type of token (tag or operator).\n      if (inTag >= 0) {\n        var tv = (inTag == x) ? null : ts(inTag, x);\n        if (specials.indexOf(tv) < 0) {\n          currentPart.tag = tv;\n        } else {\n          currentPart.oper = tv;\n        }\n        inTag = -1;\n      }\n    };\n\n    var endId = function() {\n      // Called when the tokenizer might be at the end of an ID portion of a\n      // match.\n      if (inId >= 0) {\n        currentPart.id = ts(inId, x).replace(/\\\\/g, '');\n        inId = -1;\n      }\n    };\n\n    var endClass = function() {\n      // Called when the tokenizer might be at the end of a class name\n      // match. CSS allows for multiple classes, so we augment the\n      // current item with another class in its list.\n      if (inClass >= 0) {\n        currentPart.classes.push(ts(inClass + 1, x).replace(/\\\\/g, ''));\n        inClass = -1;\n      }\n    };\n\n    var endAll = function() {\n      // at the end of a simple fragment, so wall off the matches\n      endId(); endTag(); endClass();\n    };\n\n    var endPart = function() {\n      endAll();\n      if (inPseudo >= 0) {\n        currentPart.pseudos.push({ name: ts(inPseudo + 1, x) });\n      }\n      // Hint to the selector engine to tell it whether or not it\n      // needs to do any iteration. Many simple selectors don't, and\n      // we can avoid significant construction-time work by advising\n      // the system to skip them.\n      currentPart.loops = currentPart.pseudos.length ||\n                          currentPart.attrs.length ||\n                          currentPart.classes.length;\n\n      // save the full expression as a string\n      currentPart.oquery = currentPart.query = ts(pStart, x);\n\n\n      // otag/tag are hints to suggest to the system whether or not\n      // it's an operator or a tag. We save a copy of otag since the\n      // tag name is cast to upper-case in regular HTML matches. The\n      // system has a global switch to figure out if the current\n      // expression needs to be case sensitive or not and it will use\n      // otag or tag accordingly\n      currentPart.otag = currentPart.tag = (currentPart.oper) ?\n                                                     null :\n                                                     (currentPart.tag || '*');\n\n      if (currentPart.tag) {\n        // if we're in a case-insensitive HTML doc, we likely want\n        // the toUpperCase when matching on element.tagName. If we\n        // do it here, we can skip the string op per node\n        // comparison\n        currentPart.tag = currentPart.tag.toUpperCase();\n      }\n\n      // add the part to the list\n      if (queryParts.length && (queryParts[queryParts.length - 1].oper)) {\n        // operators are always infix, so we remove them from the\n        // list and attach them to the next match. The evaluator is\n        // responsible for sorting out how to handle them.\n        currentPart.infixOper = queryParts.pop();\n        currentPart.query = currentPart.infixOper.query + ' ' +\n            currentPart.query;\n      }\n      queryParts.push(currentPart);\n\n      currentPart = null;\n    };\n\n    // iterate over the query, character by character, building up a\n    // list of query part objects\n    for (; lc = cc, cc = query.charAt(x), x < ql; x++) {\n      //    cc: the current character in the match\n      //    lc: the last character (if any)\n\n      // someone is trying to escape something, so don't try to match any\n      // fragments. We assume we're inside a literal.\n      if (lc == '\\\\') {\n        continue;\n      }\n      if (!currentPart) { // a part was just ended or none has yet been created\n        // NOTE: I hate all this alloc, but it's shorter than writing tons of\n        // if's\n        pStart = x;\n        //  rules describe full CSS sub-expressions, like:\n        //    #someId\n        //    .className:first-child\n        //  but not:\n        //    thinger > div.howdy[type=thinger]\n        //  the individual components of the previous query would be\n        //  split into 3 parts that would be represented a structure\n        //  like:\n        //    [\n        //      {\n        //        query: 'thinger',\n        //        tag: 'thinger',\n        //      },\n        //      {\n        //        query: 'div.howdy[type=thinger]',\n        //        classes: ['howdy'],\n        //        infixOper: {\n        //          query: '>',\n        //          oper: '>',\n        //        }\n        //      },\n        //    ]\n        currentPart = {\n          query: null, // the full text of the part's rule\n          pseudos: [], // CSS supports multiple pseudo-class matches in a single\n              // rule\n          attrs: [],  // CSS supports multi-attribute match, so we need an array\n          classes: [], // class matches may be additive,\n              // e.g.: .thinger.blah.howdy\n          tag: null,  // only one tag...\n          oper: null, // ...or operator per component. Note that these wind up\n              // being exclusive.\n          id: null,   // the id component of a rule\n          getTag: function() {\n            return (caseSensitive) ? this.otag : this.tag;\n          }\n        };\n\n        // if we don't have a part, we assume we're going to start at\n        // the beginning of a match, which should be a tag name. This\n        // might fault a little later on, but we detect that and this\n        // iteration will still be fine.\n        inTag = x;\n      }\n\n      if (inBrackets >= 0) {\n        // look for a the close first\n        if (cc == ']') { // if we're in a [...] clause and we end, do assignment\n          if (!cp.attr) {\n            // no attribute match was previously begun, so we\n            // assume this is an attribute existence match in the\n            // form of [someAttributeName]\n            cp.attr = ts(inBrackets + 1, x);\n          } else {\n            // we had an attribute already, so we know that we're\n            // matching some sort of value, as in [attrName=howdy]\n            cp.matchFor = ts((inMatchFor || inBrackets + 1), x);\n          }\n          var cmf = cp.matchFor;\n          if (cmf) {\n            // try to strip quotes from the matchFor value. We want\n            // [attrName=howdy] to match the same\n            //  as [attrName = 'howdy' ]\n            if ((cmf.charAt(0) == '\"') || (cmf.charAt(0) == \"'\")) {\n              cp.matchFor = cmf.slice(1, -1);\n            }\n          }\n          // end the attribute by adding it to the list of attributes.\n          currentPart.attrs.push(cp);\n          cp = null; // necessary?\n          inBrackets = inMatchFor = -1;\n        } else if (cc == '=') {\n          // if the last char was an operator prefix, make sure we\n          // record it along with the '=' operator.\n          var addToCc = ('|~^$*'.indexOf(lc) >= 0) ? lc : '';\n          cp.type = addToCc + cc;\n          cp.attr = ts(inBrackets + 1, x - addToCc.length);\n          inMatchFor = x + 1;\n        }\n        // now look for other clause parts\n      } else if (inParens >= 0) {\n        // if we're in a parenthetical expression, we need to figure\n        // out if it's attached to a pseudo-selector rule like\n        // :nth-child(1)\n        if (cc == ')') {\n          if (inPseudo >= 0) {\n            cp.value = ts(inParens + 1, x);\n          }\n          inPseudo = inParens = -1;\n        }\n      } else if (cc == '#') {\n        // start of an ID match\n        endAll();\n        inId = x + 1;\n      } else if (cc == '.') {\n        // start of a class match\n        endAll();\n        inClass = x;\n      } else if (cc == ':') {\n        // start of a pseudo-selector match\n        endAll();\n        inPseudo = x;\n      } else if (cc == '[') {\n        // start of an attribute match.\n        endAll();\n        inBrackets = x;\n        // provide a new structure for the attribute match to fill-in\n        cp = {\n          /*=====\n          attr: null, type: null, matchFor: null\n          =====*/\n        };\n      } else if (cc == '(') {\n        // we really only care if we've entered a parenthetical\n        // expression if we're already inside a pseudo-selector match\n        if (inPseudo >= 0) {\n          // provide a new structure for the pseudo match to fill-in\n          cp = {name: ts(inPseudo + 1, x), value: null};\n          currentPart.pseudos.push(cp);\n        }\n        inParens = x;\n      } else if (\n        (cc == ' ') &&\n        // if it's a space char and the last char is too, consume the\n        // current one without doing more work\n        (lc != cc)\n      ) {\n        endPart();\n      }\n    }\n    return queryParts;\n  };\n\n\n  ////////////////////////////////////////////////////////////////////////\n  // DOM query infrastructure\n  ////////////////////////////////////////////////////////////////////////\n\n  var agree = function(first, second) {\n    // the basic building block of the yes/no chaining system. agree(f1,\n    // f2) generates a new function which returns the boolean results of\n    // both of the passed functions to a single logical-anded result. If\n    // either are not passed, the other is used exclusively.\n    if (!first) {\n      return second;\n    }\n    if (!second) {\n      return first;\n    }\n\n    return function() {\n      return first.apply(window, arguments) && second.apply(window, arguments);\n    }\n  };\n\n  /**\n   * @param {(number|string|Node)} i\n   * @param {Array=} opt_arr\n   */\n  function getArr(i, opt_arr) {\n    // helps us avoid array alloc when we don't need it\n    var r = opt_arr || [];\n    if (i) {\n      r.push(i);\n    }\n    return r;\n  }\n\n  var isElement = function(n) {\n    return (1 == n.nodeType);\n  };\n\n  // FIXME: need to coalesce getAttr with defaultGetter\n  var blank = '';\n  var getAttr = function(elem, attr) {\n    if (!elem) {\n      return blank;\n    }\n    if (attr == 'class') {\n      return elem.className || blank;\n    }\n    if (attr == 'for') {\n      return elem.htmlFor || blank;\n    }\n    if (attr == 'style') {\n      return elem.style.cssText || blank;\n    }\n    return (caseSensitive ? elem.getAttribute(attr) :\n        elem.getAttribute(attr, 2)) || blank;\n  };\n\n  var attrs = {\n    '*=': function(attr, value) {\n      return function(elem) {\n        // E[foo*=\"bar\"]\n        //    an E element whose \"foo\" attribute value contains\n        //    the substring \"bar\"\n        return (getAttr(elem, attr).indexOf(value) >= 0);\n      }\n    },\n    '^=': function(attr, value) {\n      // E[foo^=\"bar\"]\n      //    an E element whose \"foo\" attribute value begins exactly\n      //    with the string \"bar\"\n      return function(elem) {\n        return (getAttr(elem, attr).indexOf(value) == 0);\n      }\n    },\n    '$=': function(attr, value) {\n      // E[foo$=\"bar\"]\n      //    an E element whose \"foo\" attribute value ends exactly\n      //    with the string \"bar\"\n      var tval = ' ' + value;\n      return function(elem) {\n        var ea = ' ' + getAttr(elem, attr);\n        return (ea.lastIndexOf(tval) == (ea.length - tval.length));\n      }\n    },\n    '~=': function(attr, value) {\n      // E[foo~=\"bar\"]\n      //    an E element whose \"foo\" attribute value is a list of\n      //    space-separated values, one of which is exactly equal\n      //    to \"bar\"\n\n      var tval = ' ' + value + ' ';\n      return function(elem) {\n        var ea = ' ' + getAttr(elem, attr) + ' ';\n        return (ea.indexOf(tval) >= 0);\n      }\n    },\n    '|=': function(attr, value) {\n      // E[hreflang|=\"en\"]\n      //    an E element whose \"hreflang\" attribute has a\n      //    hyphen-separated list of values beginning (from the\n      //    left) with \"en\"\n      value = ' ' + value;\n      return function(elem) {\n        var ea = ' ' + getAttr(elem, attr);\n        return (\n          (ea == value) ||\n          (ea.indexOf(value + '-') == 0)\n        );\n      }\n    },\n    '=': function(attr, value) {\n      return function(elem) {\n        return (getAttr(elem, attr) == value);\n      }\n    }\n  };\n\n  // avoid testing for node type if we can. Defining this in the negative\n  // here to avoid negation in the fast path.\n  var noNextElementSibling = (\n    typeof goog.dom.getDocument().firstChild.nextElementSibling == 'undefined'\n  );\n  var nSibling = !noNextElementSibling ? 'nextElementSibling' : 'nextSibling';\n  var pSibling = !noNextElementSibling ?\n                    'previousElementSibling' :\n                    'previousSibling';\n  var simpleNodeTest = (noNextElementSibling ? isElement : goog.functions.TRUE);\n\n  var _lookLeft = function(node) {\n    while (node = node[pSibling]) {\n      if (simpleNodeTest(node)) {\n        return false;\n      }\n    }\n    return true;\n  };\n\n  var _lookRight = function(node) {\n    while (node = node[nSibling]) {\n      if (simpleNodeTest(node)) {\n        return false;\n      }\n    }\n    return true;\n  };\n\n  var getNodeIndex = function(node) {\n    var root = node.parentNode;\n    var i = 0,\n        tret = root[childNodesName],\n        ci = (node['_i'] || -1),\n        cl = (root['_l'] || -1);\n\n    if (!tret) {\n      return -1;\n    }\n    var l = tret.length;\n\n    // we calculate the parent length as a cheap way to invalidate the\n    // cache. It's not 100% accurate, but it's much more honest than what\n    // other libraries do\n    if (cl == l && ci >= 0 && cl >= 0) {\n      // if it's legit, tag and release\n      return ci;\n    }\n\n    // else re-key things\n    root['_l'] = l;\n    ci = -1;\n    var te = root['firstElementChild'] || root['firstChild'];\n    for (; te; te = te[nSibling]) {\n      if (simpleNodeTest(te)) {\n        te['_i'] = ++i;\n        if (node === te) {\n          // NOTE:\n          //  shortcutting the return at this step in indexing works\n          //  very well for benchmarking but we avoid it here since\n          //  it leads to potential O(n^2) behavior in sequential\n          //  getNodexIndex operations on a previously un-indexed\n          //  parent. We may revisit this at a later time, but for\n          //  now we just want to get the right answer more often\n          //  than not.\n          ci = i;\n        }\n      }\n    }\n    return ci;\n  };\n\n  var isEven = function(elem) {\n    return !((getNodeIndex(elem)) % 2);\n  };\n\n  var isOdd = function(elem) {\n    return (getNodeIndex(elem)) % 2;\n  };\n\n  var pseudos = {\n    'checked': function(name, condition) {\n      return function(elem) {\n        return elem.checked || elem.attributes['checked'];\n      }\n    },\n    'first-child': function() {\n      return _lookLeft;\n    },\n    'last-child': function() {\n      return _lookRight;\n    },\n    'only-child': function(name, condition) {\n      return function(node) {\n        if (!_lookLeft(node)) {\n          return false;\n        }\n        if (!_lookRight(node)) {\n          return false;\n        }\n        return true;\n      };\n    },\n    'empty': function(name, condition) {\n      return function(elem) {\n        // DomQuery and jQuery get this wrong, oddly enough.\n        // The CSS 3 selectors spec is pretty explicit about it, too.\n        var cn = elem.childNodes;\n        var cnl = elem.childNodes.length;\n        // if(!cnl) { return true; }\n        for (var x = cnl - 1; x >= 0; x--) {\n          var nt = cn[x].nodeType;\n          if ((nt === 1) || (nt == 3)) {\n            return false;\n          }\n        }\n        return true;\n      }\n    },\n    'contains': function(name, condition) {\n      var cz = condition.charAt(0);\n      if (cz == '\"' || cz == \"'\") { // Remove quotes.\n        condition = condition.slice(1, -1);\n      }\n      return function(elem) {\n        return (elem.innerHTML.indexOf(condition) >= 0);\n      }\n    },\n    'not': function(name, condition) {\n      var p = getQueryParts(condition)[0];\n      var ignores = { el: 1 };\n      if (p.tag != '*') {\n        ignores.tag = 1;\n      }\n      if (!p.classes.length) {\n        ignores.classes = 1;\n      }\n      var ntf = getSimpleFilterFunc(p, ignores);\n      return function(elem) {\n        return !ntf(elem);\n      }\n    },\n    'nth-child': function(name, condition) {\n      function pi(n) {\n        return parseInt(n, 10);\n      }\n      // avoid re-defining function objects if we can\n      if (condition == 'odd') {\n        return isOdd;\n      } else if (condition == 'even') {\n        return isEven;\n      }\n      // FIXME: can we shorten this?\n      if (condition.indexOf('n') != -1) {\n        var tparts = condition.split('n', 2);\n        var pred = tparts[0] ? ((tparts[0] == '-') ? -1 : pi(tparts[0])) : 1;\n        var idx = tparts[1] ? pi(tparts[1]) : 0;\n        var lb = 0, ub = -1;\n        if (pred > 0) {\n          if (idx < 0) {\n            idx = (idx % pred) && (pred + (idx % pred));\n          } else if (idx > 0) {\n            if (idx >= pred) {\n              lb = idx - idx % pred;\n            }\n            idx = idx % pred;\n          }\n        } else if (pred < 0) {\n          pred *= -1;\n          // idx has to be greater than 0 when pred is negative;\n          // shall we throw an error here?\n          if (idx > 0) {\n            ub = idx;\n            idx = idx % pred;\n          }\n        }\n        if (pred > 0) {\n          return function(elem) {\n            var i = getNodeIndex(elem);\n            return (i >= lb) && (ub < 0 || i <= ub) && ((i % pred) == idx);\n          }\n        } else {\n          condition = idx;\n        }\n      }\n      var ncount = pi(condition);\n      return function(elem) {\n        return (getNodeIndex(elem) == ncount);\n      }\n    }\n  };\n\n  var defaultGetter = (legacyIE) ? function(cond) {\n    var clc = cond.toLowerCase();\n    if (clc == 'class') {\n      cond = 'className';\n    }\n    return function(elem) {\n      return caseSensitive ? elem.getAttribute(cond) : elem[cond] || elem[clc];\n    }\n  } : function(cond) {\n    return function(elem) {\n      return elem && elem.getAttribute && elem.hasAttribute(cond);\n    }\n  };\n\n  var getSimpleFilterFunc = function(query, ignores) {\n    // Generates a node tester function based on the passed query part. The\n    // query part is one of the structures generated by the query parser when it\n    // creates the query AST. The 'ignores' object specifies which (if any)\n    // tests to skip, allowing the system to avoid duplicating work where it\n    // may have already been taken into account by other factors such as how\n    // the nodes to test were fetched in the first place.\n    if (!query) {\n      return goog.functions.TRUE;\n    }\n    ignores = ignores || {};\n\n    var ff = null;\n\n    if (!ignores.el) {\n      ff = agree(ff, isElement);\n    }\n\n    if (!ignores.tag) {\n      if (query.tag != '*') {\n        ff = agree(ff, function(elem) {\n          return (elem && (elem.tagName == query.getTag()));\n        });\n      }\n    }\n\n    if (!ignores.classes) {\n      goog.array.forEach(query.classes, function(cname, idx, arr) {\n        // Get the class name.\n        var re = new RegExp('(?:^|\\\\s)' + cname + '(?:\\\\s|$)');\n        ff = agree(ff, function(elem) {\n          return re.test(elem.className);\n        });\n        ff.count = idx;\n      });\n    }\n\n    if (!ignores.pseudos) {\n      goog.array.forEach(query.pseudos, function(pseudo) {\n        var pn = pseudo.name;\n        if (pseudos[pn]) {\n          ff = agree(ff, pseudos[pn](pn, pseudo.value));\n        }\n      });\n    }\n\n    if (!ignores.attrs) {\n      goog.array.forEach(query.attrs, function(attr) {\n        var matcher;\n        var a = attr.attr;\n        // type, attr, matchFor\n        if (attr.type && attrs[attr.type]) {\n          matcher = attrs[attr.type](a, attr.matchFor);\n        } else if (a.length) {\n          matcher = defaultGetter(a);\n        }\n        if (matcher) {\n          ff = agree(ff, matcher);\n        }\n      });\n    }\n\n    if (!ignores.id) {\n      if (query.id) {\n        ff = agree(ff, function(elem) {\n          return (!!elem && (elem.id == query.id));\n        });\n      }\n    }\n\n    if (!ff) {\n      if (!('default' in ignores)) {\n        ff = goog.functions.TRUE;\n      }\n    }\n    return ff;\n  };\n\n  var nextSiblingIterator = function(filterFunc) {\n    return function(node, ret, bag) {\n      while (node = node[nSibling]) {\n        if (noNextElementSibling && (!isElement(node))) {\n          continue;\n        }\n        if (\n          (!bag || _isUnique(node, bag)) &&\n          filterFunc(node)\n        ) {\n          ret.push(node);\n        }\n        break;\n      }\n      return ret;\n    };\n  };\n\n  var nextSiblingsIterator = function(filterFunc) {\n    return function(root, ret, bag) {\n      var te = root[nSibling];\n      while (te) {\n        if (simpleNodeTest(te)) {\n          if (bag && !_isUnique(te, bag)) {\n            break;\n          }\n          if (filterFunc(te)) {\n            ret.push(te);\n          }\n        }\n        te = te[nSibling];\n      }\n      return ret;\n    };\n  };\n\n  // Get an array of child *elements*, skipping text and comment nodes\n  var _childElements = function(filterFunc) {\n    filterFunc = filterFunc || goog.functions.TRUE;\n    return function(root, ret, bag) {\n      var te, x = 0, tret = root[childNodesName];\n      while (te = tret[x++]) {\n        if (\n          simpleNodeTest(te) &&\n          (!bag || _isUnique(te, bag)) &&\n          (filterFunc(te, x))\n        ) {\n          ret.push(te);\n        }\n      }\n      return ret;\n    };\n  };\n\n  // test to see if node is below root\n  var _isDescendant = function(node, root) {\n    var pn = node.parentNode;\n    while (pn) {\n      if (pn == root) {\n        break;\n      }\n      pn = pn.parentNode;\n    }\n    return !!pn;\n  };\n\n  var _getElementsFuncCache = {};\n\n  var getElementsFunc = function(query) {\n    var retFunc = _getElementsFuncCache[query.query];\n    // If we've got a cached dispatcher, just use that.\n    if (retFunc) {\n      return retFunc;\n    }\n    // Else, generate a new one.\n\n    // NOTE:\n    //    This function returns a function that searches for nodes and\n    //    filters them. The search may be specialized by infix operators\n    //    (\">\", \"~\", or \"+\") else it will default to searching all\n    //    descendants (the \" \" selector). Once a group of children is\n    //    found, a test function is applied to weed out the ones we\n    //    don't want. Many common cases can be fast-pathed. We spend a\n    //    lot of cycles to create a dispatcher that doesn't do more work\n    //    than necessary at any point since, unlike this function, the\n    //    dispatchers will be called every time. The logic of generating\n    //    efficient dispatchers looks like this in pseudo code:\n    //\n    //    # if it's a purely descendant query (no \">\", \"+\", or \"~\" modifiers)\n    //    if infixOperator == \" \":\n    //      if only(id):\n    //        return def(root):\n    //          return d.byId(id, root);\n    //\n    //      elif id:\n    //        return def(root):\n    //          return filter(d.byId(id, root));\n    //\n    //      elif cssClass && getElementsByClassName:\n    //        return def(root):\n    //          return filter(root.getElementsByClassName(cssClass));\n    //\n    //      elif only(tag):\n    //        return def(root):\n    //          return root.getElementsByTagName(tagName);\n    //\n    //      else:\n    //        # search by tag name, then filter\n    //        return def(root):\n    //          return filter(root.getElementsByTagName(tagName||\"*\"));\n    //\n    //    elif infixOperator == \">\":\n    //      # search direct children\n    //      return def(root):\n    //        return filter(root.children);\n    //\n    //    elif infixOperator == \"+\":\n    //      # search next sibling\n    //      return def(root):\n    //        return filter(root.nextElementSibling);\n    //\n    //    elif infixOperator == \"~\":\n    //      # search rightward siblings\n    //      return def(root):\n    //        return filter(nextSiblings(root));\n\n    var io = query.infixOper;\n    var oper = (io ? io.oper : '');\n    // The default filter func which tests for all conditions in the query\n    // part. This is potentially inefficient, so some optimized paths may\n    // re-define it to test fewer things.\n    var filterFunc = getSimpleFilterFunc(query, { el: 1 });\n    var qt = query.tag;\n    var wildcardTag = ('*' == qt);\n    var ecs = goog.dom.getDocument()['getElementsByClassName'];\n\n    if (!oper) {\n      // If there's no infix operator, then it's a descendant query. ID\n      // and \"elements by class name\" variants can be accelerated so we\n      // call them out explicitly:\n      if (query.id) {\n        // Testing shows that the overhead of goog.functions.TRUE() is\n        // acceptable and can save us some bytes vs. re-defining the function\n        // everywhere.\n        filterFunc = (!query.loops && wildcardTag) ?\n          goog.functions.TRUE :\n          getSimpleFilterFunc(query, { el: 1, id: 1 });\n\n        retFunc = function(root, arr) {\n          var te = goog.dom.getDomHelper(root).getElement(query.id);\n          if (!te || !filterFunc(te)) {\n            return;\n          }\n          if (9 == root.nodeType) { // If root's a doc, we just return directly.\n            return getArr(te, arr);\n          } else { // otherwise check ancestry\n            if (_isDescendant(te, root)) {\n              return getArr(te, arr);\n            }\n          }\n        };\n      } else if (\n        ecs &&\n        // isAlien check. Workaround for Prototype.js being totally evil/dumb.\n        /\\{\\s*\\[native code\\]\\s*\\}/.test(String(ecs)) &&\n        query.classes.length &&\n        // WebKit bug where quirks-mode docs select by class w/o case\n        // sensitivity.\n        !cssCaseBug\n      ) {\n        // it's a class-based query and we've got a fast way to run it.\n\n        // ignore class and ID filters since we will have handled both\n        filterFunc = getSimpleFilterFunc(query, { el: 1, classes: 1, id: 1 });\n        var classesString = query.classes.join(' ');\n        retFunc = function(root, arr) {\n          var ret = getArr(0, arr), te, x = 0;\n          var tret = root.getElementsByClassName(classesString);\n          while ((te = tret[x++])) {\n            if (filterFunc(te, root)) {\n              ret.push(te);\n            }\n          }\n          return ret;\n        };\n\n      } else if (!wildcardTag && !query.loops) {\n        // it's tag only. Fast-path it.\n        retFunc = function(root, arr) {\n          var ret = getArr(0, arr), te, x = 0;\n          var tret = root.getElementsByTagName(query.getTag());\n          while ((te = tret[x++])) {\n            ret.push(te);\n          }\n          return ret;\n        };\n      } else {\n        // the common case:\n        //    a descendant selector without a fast path. By now it's got\n        //    to have a tag selector, even if it's just \"*\" so we query\n        //    by that and filter\n        filterFunc = getSimpleFilterFunc(query, { el: 1, tag: 1, id: 1 });\n        retFunc = function(root, arr) {\n          var ret = getArr(0, arr), te, x = 0;\n          // we use getTag() to avoid case sensitivity issues\n          var tret = root.getElementsByTagName(query.getTag());\n          while (te = tret[x++]) {\n            if (filterFunc(te, root)) {\n              ret.push(te);\n            }\n          }\n          return ret;\n        };\n      }\n    } else {\n      // the query is scoped in some way. Instead of querying by tag we\n      // use some other collection to find candidate nodes\n      var skipFilters = { el: 1 };\n      if (wildcardTag) {\n        skipFilters.tag = 1;\n      }\n      filterFunc = getSimpleFilterFunc(query, skipFilters);\n      if ('+' == oper) {\n        retFunc = nextSiblingIterator(filterFunc);\n      } else if ('~' == oper) {\n        retFunc = nextSiblingsIterator(filterFunc);\n      } else if ('>' == oper) {\n        retFunc = _childElements(filterFunc);\n      }\n    }\n    // cache it and return\n    return _getElementsFuncCache[query.query] = retFunc;\n  };\n\n  var filterDown = function(root, queryParts) {\n    // NOTE:\n    //    this is the guts of the DOM query system. It takes a list of\n    //    parsed query parts and a root and finds children which match\n    //    the selector represented by the parts\n    var candidates = getArr(root), qp, x, te, qpl = queryParts.length, bag, ret;\n\n    for (var i = 0; i < qpl; i++) {\n      ret = [];\n      qp = queryParts[i];\n      x = candidates.length - 1;\n      if (x > 0) {\n        // if we have more than one root at this level, provide a new\n        // hash to use for checking group membership but tell the\n        // system not to post-filter us since we will already have been\n        // guaranteed to be unique\n        bag = {};\n        ret.nozip = true;\n      }\n      var gef = getElementsFunc(qp);\n      for (var j = 0; te = candidates[j]; j++) {\n        // for every root, get the elements that match the descendant\n        // selector, adding them to the 'ret' array and filtering them\n        // via membership in this level's bag. If there are more query\n        // parts, then this level's return will be used as the next\n        // level's candidates\n        gef(te, ret, bag);\n      }\n      if (!ret.length) { break; }\n      candidates = ret;\n    }\n    return ret;\n  };\n\n  ////////////////////////////////////////////////////////////////////////\n  // the query runner\n  ////////////////////////////////////////////////////////////////////////\n\n  // these are the primary caches for full-query results. The query\n  // dispatcher functions are generated then stored here for hash lookup in\n  // the future\n  var _queryFuncCacheDOM = {},\n    _queryFuncCacheQSA = {};\n\n  // this is the second level of splitting, from full-length queries (e.g.,\n  // 'div.foo .bar') into simple query expressions (e.g., ['div.foo',\n  // '.bar'])\n  var getStepQueryFunc = function(query) {\n    var qparts = getQueryParts(goog.string.trim(query));\n\n    // if it's trivial, avoid iteration and zipping costs\n    if (qparts.length == 1) {\n      // We optimize this case here to prevent dispatch further down the\n      // chain, potentially slowing things down. We could more elegantly\n      // handle this in filterDown(), but it's slower for simple things\n      // that need to be fast (e.g., '#someId').\n      var tef = getElementsFunc(qparts[0]);\n      return function(root) {\n        var r = tef(root, []);\n        if (r) { r.nozip = true; }\n        return r;\n      }\n    }\n\n    // otherwise, break it up and return a runner that iterates over the parts\n    // recursively\n    return function(root) {\n      return filterDown(root, qparts);\n    }\n  };\n\n  // NOTES:\n  //  * we can't trust QSA for anything but document-rooted queries, so\n  //    caching is split into DOM query evaluators and QSA query evaluators\n  //  * caching query results is dirty and leak-prone (or, at a minimum,\n  //    prone to unbounded growth). Other toolkits may go this route, but\n  //    they totally destroy their own ability to manage their memory\n  //    footprint. If we implement it, it should only ever be with a fixed\n  //    total element reference # limit and an LRU-style algorithm since JS\n  //    has no weakref support. Caching compiled query evaluators is also\n  //    potentially problematic, but even on large documents the size of the\n  //    query evaluators is often < 100 function objects per evaluator (and\n  //    LRU can be applied if it's ever shown to be an issue).\n  //  * since IE's QSA support is currently only for HTML documents and even\n  //    then only in IE 8's 'standards mode', we have to detect our dispatch\n  //    route at query time and keep 2 separate caches. Ugg.\n\n  var qsa = 'querySelectorAll';\n\n  // some versions of Safari provided QSA, but it was buggy and crash-prone.\n  // We need to detect the right 'internal' webkit version to make this work.\n  var qsaAvail = (\n    !!goog.dom.getDocument()[qsa] &&\n    // see #5832\n    (!goog.userAgent.WEBKIT || goog.userAgent.isVersionOrHigher('526'))\n  );\n\n  /**\n   * @param {(string|Array)} query\n   * @param {boolean=} opt_forceDOM\n   * @return {function((string|Node)): !Array}\n   */\n  var getQueryFunc = function(query, opt_forceDOM) {\n\n    if (qsaAvail) {\n      // if we've got a cached variant and we think we can do it, run it!\n      var qsaCached = _queryFuncCacheQSA[query];\n      if (qsaCached && !opt_forceDOM) {\n        return qsaCached;\n      }\n    }\n\n    // else if we've got a DOM cached variant, assume that we already know\n    // all we need to and use it\n    var domCached = _queryFuncCacheDOM[query];\n    if (domCached) {\n      return domCached;\n    }\n\n    // TODO:\n    //    today we're caching DOM and QSA branches separately so we\n    //    recalc useQSA every time. If we had a way to tag root+query\n    //    efficiently, we'd be in good shape to do a global cache.\n\n    var qcz = query.charAt(0);\n    var nospace = (-1 == query.indexOf(' '));\n\n    // byId searches are wicked fast compared to QSA, even when filtering\n    // is required\n    if ((query.indexOf('#') >= 0) && (nospace)) {\n      opt_forceDOM = true;\n    }\n\n    var useQSA = (\n      qsaAvail && (!opt_forceDOM) &&\n      // as per CSS 3, we can't currently start w/ combinator:\n      //    http://www.w3.org/TR/css3-selectors/#w3cselgrammar\n      (specials.indexOf(qcz) == -1) &&\n      // IE's QSA impl sucks on pseudos\n      (!legacyIE || (query.indexOf(':') == -1)) &&\n\n      (!(cssCaseBug && (query.indexOf('.') >= 0))) &&\n\n      // FIXME:\n      //    need to tighten up browser rules on ':contains' and '|=' to\n      //    figure out which aren't good\n      (query.indexOf(':contains') == -1) &&\n      (query.indexOf('|=') == -1) // some browsers don't understand it\n    );\n\n    // TODO:\n    //    if we've got a descendant query (e.g., '> .thinger' instead of\n    //    just '.thinger') in a QSA-able doc, but are passed a child as a\n    //    root, it should be possible to give the item a synthetic ID and\n    //    trivially rewrite the query to the form '#synid > .thinger' to\n    //    use the QSA branch\n\n\n    if (useQSA) {\n      var tq = (specials.indexOf(query.charAt(query.length - 1)) >= 0) ?\n            (query + ' *') : query;\n      return _queryFuncCacheQSA[query] = function(root) {\n        try {\n          // the QSA system contains an egregious spec bug which\n          // limits us, effectively, to only running QSA queries over\n          // entire documents.  See:\n          //    http://ejohn.org/blog/thoughts-on-queryselectorall/\n          //  despite this, we can also handle QSA runs on simple\n          //  selectors, but we don't want detection to be expensive\n          //  so we're just checking for the presence of a space char\n          //  right now. Not elegant, but it's cheaper than running\n          //  the query parser when we might not need to\n          if (!((9 == root.nodeType) || nospace)) {\n            throw new Error('');\n          }\n          var r = root[qsa](tq);\n          // IE QSA queries may incorrectly include comment nodes, so we throw\n          // the zipping function into 'remove' comments mode instead of the\n          // normal 'skip it' which every other QSA-clued browser enjoys\n          // skip expensive duplication checks and just wrap in an array.\n          if (legacyIE) {\n            r.commentStrip = true;\n          } else {\n            r.nozip = true;\n          }\n          return r;\n        } catch (e) {\n          // else run the DOM branch on this query, ensuring that we\n          // default that way in the future\n          return getQueryFunc(query, true)(root);\n        }\n      };\n    } else {\n      // DOM branch\n      var parts = query.split(/\\s*,\\s*/);\n      return _queryFuncCacheDOM[query] =\n                 ((parts.length < 2) ?\n                      // if not a compound query (e.g., '.foo, .bar'), cache and\n                      // return a dispatcher\n                      getStepQueryFunc(query) :\n                      // if it *is* a complex query, break it up into its\n                      // constituent parts and return a dispatcher that will\n                      // merge the parts when run\n                      function(root) {\n                        var pindex =\n                                0,  // avoid array alloc for every invocation\n                            ret = [],\n                            tp;\n                        while (tp = parts[pindex++]) {\n                          ret = ret.concat(getStepQueryFunc(tp)(root));\n                        }\n                        return ret;\n                      });\n    }\n  };\n\n  var _zipIdx = 0;\n\n  // NOTE:\n  //    this function is Moo inspired, but our own impl to deal correctly\n  //    with XML in IE\n  var _nodeUID = legacyIE ? function(node) {\n    if (caseSensitive) {\n      // XML docs don't have uniqueID on their nodes\n      return node.getAttribute('_uid') ||\n          node.setAttribute('_uid', ++_zipIdx) || _zipIdx;\n\n    } else {\n      return node.uniqueID;\n    }\n  } :\n  function(node) {\n    return (node['_uid'] || (node['_uid'] = ++_zipIdx));\n  };\n\n  // determine if a node in is unique in a 'bag'. In this case we don't want\n  // to flatten a list of unique items, but rather just tell if the item in\n  // question is already in the bag. Normally we'd just use hash lookup to do\n  // this for us but IE's DOM is busted so we can't really count on that. On\n  // the upside, it gives us a built in unique ID function.\n  var _isUnique = function(node, bag) {\n    if (!bag) {\n      return 1;\n    }\n    var id = _nodeUID(node);\n    if (!bag[id]) {\n      return bag[id] = 1;\n    }\n    return 0;\n  };\n\n  // attempt to efficiently determine if an item in a list is a dupe,\n  // returning a list of 'uniques', hopefully in document order\n  var _zipIdxName = '_zipIdx';\n  var _zip = function(arr) {\n    if (arr && arr.nozip) {\n      return arr;\n    }\n    var ret = [];\n    if (!arr || !arr.length) {\n      return ret;\n    }\n    if (arr[0]) {\n      ret.push(arr[0]);\n    }\n    if (arr.length < 2) {\n      return ret;\n    }\n\n    _zipIdx++;\n\n    // we have to fork here for IE and XML docs because we can't set\n    // expandos on their nodes (apparently). *sigh*\n    if (legacyIE && caseSensitive) {\n      var szidx = _zipIdx + '';\n      arr[0].setAttribute(_zipIdxName, szidx);\n      for (var x = 1, te; te = arr[x]; x++) {\n        if (arr[x].getAttribute(_zipIdxName) != szidx) {\n          ret.push(te);\n        }\n        te.setAttribute(_zipIdxName, szidx);\n      }\n    } else if (legacyIE && arr.commentStrip) {\n      try {\n        for (var x = 1, te; te = arr[x]; x++) {\n          if (isElement(te)) {\n            ret.push(te);\n          }\n        }\n      } catch (e) { /* squelch */ }\n    } else {\n      if (arr[0]) {\n        arr[0][_zipIdxName] = _zipIdx;\n      }\n      for (var x = 1, te; te = arr[x]; x++) {\n        if (arr[x][_zipIdxName] != _zipIdx) {\n          ret.push(te);\n        }\n        te[_zipIdxName] = _zipIdx;\n      }\n    }\n    return ret;\n  };\n\n  /**\n   * The main executor. Type specification from above.\n   * @param {string|Array} query The query.\n   * @param {(string|Node)=} opt_root The root.\n   * @return {!Array} The elements that matched the query.\n   */\n  var query = function(query, opt_root) {\n    // NOTE: elementsById is not currently supported\n    // NOTE: ignores xpath-ish queries for now\n\n    //Set list constructor to desired value. This can change\n    //between calls, so always re-assign here.\n\n    if (!query) {\n      return [];\n    }\n\n    if (query.constructor == Array) {\n      return /** @type {!Array} */ (query);\n    }\n\n    if (!goog.isString(query)) {\n      return [query];\n    }\n\n    var root = opt_root;\n    if (goog.isString(root)) {\n      root = goog.dom.getElement(root);\n      if (!root) {\n        return [];\n      }\n    }\n\n    root = root || goog.dom.getDocument();\n    var od = root.ownerDocument || root.documentElement;\n\n    // throw the big case sensitivity switch\n\n    // NOTE:\n    //    Opera in XHTML mode doesn't detect case-sensitivity correctly\n    //    and it's not clear that there's any way to test for it\n    caseSensitive =\n        root.contentType && root.contentType == 'application/xml' ||\n        goog.userAgent.OPERA &&\n          (root.doctype || od.toString() == '[object XMLDocument]') ||\n        !!od &&\n        (legacyIE ? od.xml : (root.xmlVersion || od.xmlVersion));\n\n    // NOTE:\n    //    adding 'true' as the 2nd argument to getQueryFunc is useful for\n    //    testing the DOM branch without worrying about the\n    //    behavior/performance of the QSA branch.\n    var r = getQueryFunc(query)(root);\n\n    // FIXME(slightlyoff):\n    //    need to investigate this branch WRT dojo:#8074 and dojo:#8075\n    if (r && r.nozip) {\n      return r;\n    }\n    return _zip(r);\n  };\n\n  // FIXME: need to add infrastructure for post-filtering pseudos, ala :last\n  query.pseudos = pseudos;\n\n  return query;\n})();\n\n// TODO(arv): Please don't export here since it clobbers dead code elimination.\ngoog.exportSymbol('goog.dom.query', goog.dom.query);\ngoog.exportSymbol('goog.dom.query.pseudos', goog.dom.query.pseudos);\n","~:last-modified",1748821315608,"~:requires",["^3",["~$goog.dom","~$goog.functions","~$goog.string","~$goog","~$goog.userAgent","~$goog.array"]],"~:pom-info",["^ ","~:description","The Google Closure Library is a collection of JavaScript code\n        designed for use with the Google Closure JavaScript Compiler.\n\n        This non-official distribution was prepared by the ClojureScript\n        team at http://clojure.org/\n\n        This package contains extensions to the Google Closure Library\n        using third-party components, which may be distributed under\n        licenses other than the Apache license. Licenses for individual\n        library components may be found in source-code comments.","~:group-id","~$org.clojure","~:artifact-id","~$google-closure-library-third-party","~:name","Google Closure Library Third-Party Extensions","~:id","~$org.clojure/google-closure-library-third-party","~:url","http://code.google.com/p/closure-library/","~:parent-group-id","~$org.sonatype.oss","~:coordinate",["^L","0.0-20250515-f04e4c0e"],"~:version","0.0-20250515-f04e4c0e"],"~:goog-requires",["^3",["^>","^?","^@","^B","^C"]],"~:inspect-info",["^ ","~:js-str-offsets",[],"~:js-esm",false,"~:js-imports",[],"~:js-invalid-requires",[],"^2",["goog.dom.query"],"~:js-language","es3","~:goog-module",null,"~:goog-module-legacy-namespace",false,"~:js-warnings",[],"~:js-requires",[],"~:js-errors",[],"^R",["goog.array","goog.dom","goog.functions","goog.string","goog.userAgent"],"~:js-dynamic-imports",[],"~:goog-require-types",[],"~:uses-global-buffer",false,"~:uses-global",false,"~:uses-global-process",false],"^M",["~#url","jar:file:/home/xuelin/.m2/repository/org/clojure/google-closure-library-third-party/0.0-20250515-f04e4c0e/google-closure-library-third-party-0.0-20250515-f04e4c0e.jar!/goog/dojo/dom/query.js"],"~:provides",["^3",["^4"]],"^13",["^3",[]],"~:from-jar",true,"~:goog-src",true,"~:deps",["^A","^C","^>","^?","^@","^B"]],["^ ","^1",["c0b576cb976b90eb929938af5e9b6630cd1696f6"],"^2",["^3",["~$goog.async.Deferred.CanceledError","~$goog.async.Deferred","~$goog.async.Deferred.AlreadyCalledError"]],"^5","goog.mochikit.async.deferred.js","^6",["^7","goog/mochikit/async/deferred.js"],"^8","goog/mochikit/async/deferred.js","^9","^:","^;","/**\n * @license\n * Copyright 2005, 2007 Bob Ippolito. All Rights Reserved.\n * Copyright The Closure Library Authors.\n * SPDX-License-Identifier: MIT\n */\n\n// Portions of this code are from MochiKit, received by The Closure\n// Library Authors under the MIT license. All other code is Copyright\n// The Closure Library Authors.\n\n/**\n * @fileoverview Classes for tracking asynchronous operations and handling the\n * results. The Deferred object here is patterned after the Deferred object in\n * the Twisted python networking framework.\n *\n * See: http://twistedmatrix.com/projects/core/documentation/howto/defer.html\n *\n * Based on the Dojo code which in turn is based on the MochiKit code.\n *\n */\n\ngoog.provide('goog.async.Deferred');\ngoog.provide('goog.async.Deferred.AlreadyCalledError');\ngoog.provide('goog.async.Deferred.CanceledError');\n\ngoog.require('goog.Promise');\ngoog.require('goog.Thenable');\ngoog.require('goog.array');\ngoog.require('goog.asserts');\ngoog.require('goog.debug.Error');\n\n\n\n/**\n * A Deferred represents the result of an asynchronous operation. A Deferred\n * instance has no result when it is created, and is \"fired\" (given an initial\n * result) by calling `callback` or `errback`.\n *\n * Once fired, the result is passed through a sequence of callback functions\n * registered with `addCallback` or `addErrback`. The functions may\n * mutate the result before it is passed to the next function in the sequence.\n *\n * Callbacks and errbacks may be added at any time, including after the Deferred\n * has been \"fired\". If there are no pending actions in the execution sequence\n * of a fired Deferred, any new callback functions will be called with the last\n * computed result. Adding a callback function is the only way to access the\n * result of the Deferred.\n *\n * If a Deferred operation is canceled, an optional user-provided cancellation\n * function is invoked which may perform any special cleanup, followed by firing\n * the Deferred's errback sequence with a `CanceledError`. If the\n * Deferred has already fired, cancellation is ignored.\n *\n * Deferreds may be templated to a specific type they produce using generics\n * with syntax such as:\n *\n *    /** @type {goog.async.Deferred<string>} *\\\n *    var d = new goog.async.Deferred();\n *    // Compiler can infer that foo is a string.\n *    d.addCallback(function(foo) {...});\n *    d.callback('string');  // Checked to be passed a string\n *\n * Since deferreds are often used to produce different values across a chain,\n * the type information is not propagated across chains, but rather only\n * associated with specifically cast objects.\n *\n * @param {Function=} opt_onCancelFunction A function that will be called if the\n *     Deferred is canceled. If provided, this function runs before the\n *     Deferred is fired with a `CanceledError`.\n * @param {Object=} opt_defaultScope The default object context to call\n *     callbacks and errbacks in.\n * @constructor\n * @implements {goog.Thenable<VALUE>}\n * @template VALUE\n */\ngoog.async.Deferred = function(opt_onCancelFunction, opt_defaultScope) {\n  'use strict';\n  /**\n   * Entries in the sequence are arrays containing a callback, an errback, and\n   * an optional scope. The callback or errback in an entry may be null.\n   * @type {!Array<!Array>}\n   * @private\n   */\n  this.sequence_ = [];\n\n  /**\n   * Optional function that will be called if the Deferred is canceled.\n   * @type {Function|undefined}\n   * @private\n   */\n  this.onCancelFunction_ = opt_onCancelFunction;\n\n  /**\n   * The default scope to execute callbacks and errbacks in.\n   * @type {Object}\n   * @private\n   */\n  this.defaultScope_ = opt_defaultScope || null;\n\n  /**\n   * Whether the Deferred has been fired.\n   * @type {boolean}\n   * @private\n   */\n  this.fired_ = false;\n\n  /**\n   * Whether the last result in the execution sequence was an error.\n   * @type {boolean}\n   * @private\n   */\n  this.hadError_ = false;\n\n  /**\n   * The current Deferred result, updated as callbacks and errbacks are\n   * executed.\n   * @type {*}\n   * @private\n   */\n  this.result_ = undefined;\n\n  /**\n   * Whether the Deferred is blocked waiting on another Deferred to fire. If a\n   * callback or errback returns a Deferred as a result, the execution sequence\n   * is blocked until that Deferred result becomes available.\n   * @type {boolean}\n   * @private\n   */\n  this.blocked_ = false;\n\n  /**\n   * Whether this Deferred is blocking execution of another Deferred. If this\n   * instance was returned as a result in another Deferred's execution\n   * sequence,that other Deferred becomes blocked until this instance's\n   * execution sequence completes. No additional callbacks may be added to a\n   * Deferred once it is blocking another instance.\n   * @type {boolean}\n   * @private\n   */\n  this.blocking_ = false;\n\n  /**\n   * Whether the Deferred has been canceled without having a custom cancel\n   * function.\n   * @type {boolean}\n   * @private\n   */\n  this.silentlyCanceled_ = false;\n\n  /**\n   * If an error is thrown during Deferred execution with no errback to catch\n   * it, the error is rethrown after a timeout. Reporting the error after a\n   * timeout allows execution to continue in the calling context (empty when\n   * no error is scheduled).\n   * @type {number}\n   * @private\n   */\n  this.unhandledErrorId_ = 0;\n\n  /**\n   * If this Deferred was created by branch(), this will be the \"parent\"\n   * Deferred.\n   * @type {?goog.async.Deferred}\n   * @private\n   */\n  this.parent_ = null;\n\n  /**\n   * The number of Deferred objects that have been branched off this one. This\n   * will be decremented whenever a branch is fired or canceled.\n   * @type {number}\n   * @private\n   */\n  this.branches_ = 0;\n\n  if (goog.async.Deferred.LONG_STACK_TRACES) {\n    /**\n     * Holds the stack trace at time of deferred creation if the JS engine\n     * provides the Error.captureStackTrace API.\n     * @private {?string}\n     */\n    this.constructorStack_ = null;\n    if (Error.captureStackTrace) {\n      const target = {stack: ''};\n      Error.captureStackTrace(target, goog.async.Deferred);\n      // Check if Error.captureStackTrace worked. It fails in gjstest.\n      if (typeof target.stack == 'string') {\n        // Remove first line and force stringify to prevent memory leak due to\n        // holding on to actual stack frames.\n        this.constructorStack_ = target.stack.replace(/^[^\\n]*\\n/, '');\n      }\n    }\n  }\n};\n\n\n/**\n * @define {boolean} Whether unhandled errors should always get rethrown to the\n * global scope. Defaults to false.\n *\n * NOTE(user): This has a surprising side effect that when STRICT_ERRORS\n * is true, successfully resolving a `Deferred` with a value that is `instanceof\n * Error` (other than `CanceledError`, which is treated as _not an error_ for\n * this purpose) will actually cause the `Deferred` to end up in a rejected\n * state. Thus, `Deferred.succeed(new Error()).addErrback(f)` will actually call\n * `f`. This is similar to existing behavior where (independent of\n * STRICT_ERRORS) _errbacks_ that return (rather than throw) any `Error`\n * (including `CanceledError`) will cause a rejection. We believe this behavior\n * is unintended and will try to fix it in the future to be more consistent.\n */\ngoog.async.Deferred.STRICT_ERRORS =\n    goog.define('goog.async.Deferred.STRICT_ERRORS', false);\n\n\n/**\n * @define {boolean} Whether to attempt to make stack traces long.  Defaults to\n * false.\n */\ngoog.async.Deferred.LONG_STACK_TRACES =\n    goog.define('goog.async.Deferred.LONG_STACK_TRACES', false);\n\n\n/**\n * Cancels a Deferred that has not yet been fired, or is blocked on another\n * deferred operation. If this Deferred is waiting for a blocking Deferred to\n * fire, the blocking Deferred will also be canceled.\n *\n * If this Deferred was created by calling branch() on a parent Deferred with\n * opt_propagateCancel set to true, the parent may also be canceled. If\n * opt_deepCancel is set, cancel() will be called on the parent (as well as any\n * other ancestors if the parent is also a branch). If one or more branches were\n * created with opt_propagateCancel set to true, the parent will be canceled if\n * cancel() is called on all of those branches.\n *\n * @param {boolean=} opt_deepCancel If true, cancels this Deferred's parent even\n *     if cancel() hasn't been called on some of the parent's branches. Has no\n *     effect on a branch without opt_propagateCancel set to true.\n */\ngoog.async.Deferred.prototype.cancel = function(opt_deepCancel) {\n  'use strict';\n  if (!this.hasFired()) {\n    if (this.parent_) {\n      // Get rid of the parent reference before potentially running the parent's\n      // canceler function to ensure that this cancellation isn't\n      // double-counted.\n      const parent = this.parent_;\n      delete this.parent_;\n      if (opt_deepCancel) {\n        parent.cancel(opt_deepCancel);\n      } else {\n        parent.branchCancel_();\n      }\n    }\n\n    if (this.onCancelFunction_) {\n      // Call in user-specified scope.\n      this.onCancelFunction_.call(this.defaultScope_, this);\n    } else {\n      this.silentlyCanceled_ = true;\n    }\n    if (!this.hasFired()) {\n      this.errback(new goog.async.Deferred.CanceledError(this));\n    }\n  } else if (this.result_ instanceof goog.async.Deferred) {\n    this.result_.cancel();\n  }\n};\n\n\n/**\n * Handle a single branch being canceled. Once all branches are canceled, this\n * Deferred will be canceled as well.\n *\n * @private\n */\ngoog.async.Deferred.prototype.branchCancel_ = function() {\n  'use strict';\n  this.branches_--;\n  if (this.branches_ <= 0) {\n    this.cancel();\n  }\n};\n\n\n/**\n * Called after a blocking Deferred fires. Unblocks this Deferred and resumes\n * its execution sequence.\n *\n * @param {boolean} isSuccess Whether the result is a success or an error.\n * @param {*} res The result of the blocking Deferred.\n * @private\n */\ngoog.async.Deferred.prototype.continue_ = function(isSuccess, res) {\n  'use strict';\n  this.blocked_ = false;\n  this.updateResult_(isSuccess, res);\n};\n\n\n/**\n * Updates the current result based on the success or failure of the last action\n * in the execution sequence.\n *\n * @param {boolean} isSuccess Whether the new result is a success or an error.\n * @param {*} res The result.\n * @private\n */\ngoog.async.Deferred.prototype.updateResult_ = function(isSuccess, res) {\n  'use strict';\n  this.fired_ = true;\n  this.result_ = res;\n  this.hadError_ = !isSuccess;\n  this.fire_();\n};\n\n\n/**\n * Verifies that the Deferred has not yet been fired.\n *\n * @private\n * @throws {Error} If this has already been fired.\n */\ngoog.async.Deferred.prototype.check_ = function() {\n  'use strict';\n  if (this.hasFired()) {\n    if (!this.silentlyCanceled_) {\n      throw new goog.async.Deferred.AlreadyCalledError(this);\n    }\n    this.silentlyCanceled_ = false;\n  }\n};\n\n\n/**\n * Fire the execution sequence for this Deferred by passing the starting result\n * to the first registered callback.\n * @param {VALUE=} opt_result The starting result.\n */\ngoog.async.Deferred.prototype.callback = function(opt_result) {\n  'use strict';\n  this.check_();\n  this.assertNotDeferred_(opt_result);\n  this.updateResult_(true /* isSuccess */, opt_result);\n};\n\n\n/**\n * Fire the execution sequence for this Deferred by passing the starting error\n * result to the first registered errback.\n * @param {*=} opt_result The starting error.\n */\ngoog.async.Deferred.prototype.errback = function(opt_result) {\n  'use strict';\n  this.check_();\n  this.assertNotDeferred_(opt_result);\n  this.makeStackTraceLong_(opt_result);\n  this.updateResult_(false /* isSuccess */, opt_result);\n};\n\n\n/**\n * A method that is invoked with the reason of Deferred's failure for unhandled\n * errors.\n * @type {function(*)}\n * @private\n */\ngoog.async.Deferred.unhandledErrorHandler_ = (e) => {\n  throw e;\n};\n\n\n/**\n * @param {function(*)} handler A function that will be called with the reason\n *     of Deferred's failure on unhandled errors. If none is specified, errors\n *     will fail with `throw`.\n */\ngoog.async.Deferred.setUnhandledErrorHandler = function(handler) {\n  'use strict';\n  goog.async.Deferred.unhandledErrorHandler_ = handler;\n};\n\n\n/**\n * Attempt to make the error's stack trace be long in that it contains the\n * stack trace from the point where the deferred was created on top of the\n * current stack trace to give additional context.\n * @param {*} error\n * @private\n * @suppress {missingProperties} error.stack\n */\ngoog.async.Deferred.prototype.makeStackTraceLong_ = function(error) {\n  'use strict';\n  if (!goog.async.Deferred.LONG_STACK_TRACES) {\n    return;\n  }\n  if (this.constructorStack_ && goog.isObject(error) && error.stack &&\n      // Stack looks like it was system generated. See\n      // https://code.google.com/p/v8/wiki/JavaScriptStackTraceApi\n      (/^[^\\n]+(\\n   [^\\n]+)+/).test(error.stack)) {\n    error.stack =\n        error.stack + '\\nDEFERRED OPERATION:\\n' + this.constructorStack_;\n  }\n};\n\n\n/**\n * Asserts that an object is not a Deferred.\n * @param {*} obj The object to test.\n * @throws {Error} Throws an exception if the object is a Deferred.\n * @private\n */\ngoog.async.Deferred.prototype.assertNotDeferred_ = function(obj) {\n  'use strict';\n  goog.asserts.assert(\n      !(obj instanceof goog.async.Deferred),\n      'An execution sequence may not be initiated with a blocking Deferred.');\n};\n\n\n/**\n * Register a callback function to be called with a successful result. If no\n * value is returned by the callback function, the result value is unchanged. If\n * a new value is returned, it becomes the Deferred result and will be passed to\n * the next callback in the execution sequence.\n *\n * If the function throws an error, the error becomes the new result and will be\n * passed to the next errback in the execution chain.\n *\n * If the function returns a Deferred, the execution sequence will be blocked\n * until that Deferred fires. Its result will be passed to the next callback (or\n * errback if it is an error result) in this Deferred's execution sequence.\n *\n * @param {function(this:T,VALUE):?} cb The function to be called with a\n *     successful result.\n * @param {T=} opt_scope An optional scope to call the callback in.\n * @return {!goog.async.Deferred} This Deferred.\n * @template T\n */\ngoog.async.Deferred.prototype.addCallback = function(cb, opt_scope) {\n  'use strict';\n  return this.addCallbacks(cb, null, opt_scope);\n};\n\n\n/**\n * Register a callback function to be called with an error result. If no value\n * is returned by the function, the error result is unchanged. If a new error\n * value is returned or thrown, that error becomes the Deferred result and will\n * be passed to the next errback in the execution sequence.\n *\n * If the errback function handles the error by returning a non-error value,\n * that result will be passed to the next normal callback in the sequence.\n *\n * If the function returns a Deferred, the execution sequence will be blocked\n * until that Deferred fires. Its result will be passed to the next callback (or\n * errback if it is an error result) in this Deferred's execution sequence.\n *\n * @param {function(this:T,?):?} eb The function to be called on an\n *     unsuccessful result.\n * @param {T=} opt_scope An optional scope to call the errback in.\n * @return {!goog.async.Deferred<VALUE>} This Deferred.\n * @template T\n */\ngoog.async.Deferred.prototype.addErrback = function(eb, opt_scope) {\n  'use strict';\n  return this.addCallbacks(null, eb, opt_scope);\n};\n\n\n/**\n * Registers one function as both a callback and errback.\n *\n * @param {function(this:T,?):?} f The function to be called on any result.\n * @param {T=} opt_scope An optional scope to call the function in.\n * @return {!goog.async.Deferred} This Deferred.\n * @template T\n */\ngoog.async.Deferred.prototype.addBoth = function(f, opt_scope) {\n  'use strict';\n  return this.addCallbacks(f, f, opt_scope);\n};\n\n\n/**\n * Like addBoth, but propagates uncaught exceptions in the errback.\n *\n * @param {function(this:T,?):?} f The function to be called on any result.\n * @param {T=} opt_scope An optional scope to call the function in.\n * @return {!goog.async.Deferred<VALUE>} This Deferred.\n * @template T\n */\ngoog.async.Deferred.prototype.addFinally = function(f, opt_scope) {\n  'use strict';\n  return this.addCallbacks(f, function(err) {\n    'use strict';\n    const result = f.call(/** @type {?} */ (this), err);\n    if (result === undefined) {\n      throw err;\n    }\n    return result;\n  }, opt_scope);\n};\n\n\n/**\n * Registers a callback function and an errback function at the same position\n * in the execution sequence. Only one of these functions will execute,\n * depending on the error state during the execution sequence.\n *\n * NOTE: This is not equivalent to {@code def.addCallback().addErrback()}! If\n * the callback is invoked, the errback will be skipped, and vice versa.\n *\n * @param {?(function(this:T,VALUE):?)} cb The function to be called on a\n *     successful result.\n * @param {?(function(this:T,?):?)} eb The function to be called on an\n *     unsuccessful result.\n * @param {T=} opt_scope An optional scope to call the functions in.\n * @return {!goog.async.Deferred} This Deferred.\n * @template T\n */\ngoog.async.Deferred.prototype.addCallbacks = function(cb, eb, opt_scope) {\n  'use strict';\n  goog.asserts.assert(!this.blocking_, 'Blocking Deferreds can not be re-used');\n  this.sequence_.push([cb, eb, opt_scope]);\n  if (this.hasFired()) {\n    this.fire_();\n  }\n  return this;\n};\n\n\n/**\n * Implements {@see goog.Thenable} for seamless integration with\n * {@see goog.Promise}.\n * Deferred results are mutable and may represent multiple values over\n * their lifetime. Calling `then` on a Deferred returns a Promise\n * with the result of the Deferred at that point in its callback chain.\n * Note that if the Deferred result is never mutated, and only\n * `then` calls are made, the Deferred will behave like a Promise.\n *\n * @override\n */\ngoog.async.Deferred.prototype.then = function(\n    opt_onFulfilled, opt_onRejected, opt_context) {\n  'use strict';\n  let reject;\n  let resolve;\n\n  const promise = new goog.Promise(function(res, rej) {\n    'use strict';\n    // Copying resolvers to outer scope, so that they are available when the\n    // deferred callback fires (which may be synchronous).\n    resolve = res;\n    reject = rej;\n  });\n  this.addCallbacks(resolve, function(reason) {\n    'use strict';\n    if (reason instanceof goog.async.Deferred.CanceledError) {\n      promise.cancel();\n    } else {\n      reject(reason);\n    }\n    return goog.async.Deferred.CONVERTED_TO_PROMISE_;\n  }, this);\n  return promise.then(opt_onFulfilled, opt_onRejected, opt_context);\n};\ngoog.Thenable.addImplementation(goog.async.Deferred);\n\n\n/**\n * Links another Deferred to the end of this Deferred's execution sequence. The\n * result of this execution sequence will be passed as the starting result for\n * the chained Deferred, invoking either its first callback or errback.\n *\n * @param {!goog.async.Deferred} otherDeferred The Deferred to chain.\n * @return {!goog.async.Deferred} This Deferred.\n */\ngoog.async.Deferred.prototype.chainDeferred = function(otherDeferred) {\n  'use strict';\n  this.addCallbacks(\n      otherDeferred.callback, otherDeferred.errback, otherDeferred);\n  return this;\n};\n\n\n/**\n * Makes this Deferred wait for another Deferred's execution sequence to\n * complete before continuing.\n *\n * This is equivalent to adding a callback that returns `otherDeferred`,\n * but doesn't prevent additional callbacks from being added to\n * `otherDeferred`.\n *\n * @param {!goog.async.Deferred|!goog.Thenable} otherDeferred The Deferred\n *     to wait for.\n * @return {!goog.async.Deferred} This Deferred.\n */\ngoog.async.Deferred.prototype.awaitDeferred = function(otherDeferred) {\n  'use strict';\n  if (!(otherDeferred instanceof goog.async.Deferred)) {\n    // The Thenable case.\n    return this.addCallback(function() {\n      'use strict';\n      return otherDeferred;\n    });\n  }\n  return this.addCallback(goog.bind(otherDeferred.branch, otherDeferred));\n};\n\n\n/**\n * Creates a branch off this Deferred's execution sequence, and returns it as a\n * new Deferred. The branched Deferred's starting result will be shared with the\n * parent at the point of the branch, even if further callbacks are added to the\n * parent.\n *\n * All branches at the same stage in the execution sequence will receive the\n * same starting value.\n *\n * @param {boolean=} opt_propagateCancel If cancel() is called on every child\n *     branch created with opt_propagateCancel, the parent will be canceled as\n *     well.\n * @return {!goog.async.Deferred<VALUE>} A Deferred that will be started with\n *     the computed result from this stage in the execution sequence.\n */\ngoog.async.Deferred.prototype.branch = function(opt_propagateCancel) {\n  'use strict';\n  const d = new goog.async.Deferred();\n  this.chainDeferred(d);\n  if (opt_propagateCancel) {\n    d.parent_ = this;\n    this.branches_++;\n  }\n  return d;\n};\n\n\n/**\n * @return {boolean} Whether the execution sequence has been started on this\n *     Deferred by invoking `callback` or `errback`.\n */\ngoog.async.Deferred.prototype.hasFired = function() {\n  'use strict';\n  return this.fired_;\n};\n\n\n/**\n * @param {*} res The latest result in the execution sequence.\n * @return {boolean} Whether the current result is an error that should cause\n *     the next errback to fire. May be overridden by subclasses to handle\n *     special error types.\n * @protected\n */\ngoog.async.Deferred.prototype.isError = function(res) {\n  'use strict';\n  return res instanceof Error;\n};\n\n\n/**\n * @return {boolean} Whether an errback exists in the remaining sequence.\n * @private\n */\ngoog.async.Deferred.prototype.hasErrback_ = function() {\n  'use strict';\n  return goog.array.some(this.sequence_, function(sequenceRow) {\n    'use strict';\n    // The errback is the second element in the array.\n    return typeof sequenceRow[1] === 'function';\n  });\n};\n\n\n/**\n * Return the most recent value fired.\n *\n * @return {VALUE|undefined}\n * @deprecated This method is only for facilitating migrations from other async\n *     primitives.\n */\ngoog.async.Deferred.prototype.getLastValueForMigration = function() {\n  'use strict';\n  return (this.hasFired() && !this.hadError_) ? this.result_ : undefined;\n};\n\n/** @private @const Marker object returned from `.then()` to `.fire_()`. */\ngoog.async.Deferred.CONVERTED_TO_PROMISE_ = {};\n\n/**\n * Exhausts the execution sequence while a result is available. The result may\n * be modified by callbacks or errbacks, and execution will block if the\n * returned result is an incomplete Deferred.\n *\n * @private\n */\ngoog.async.Deferred.prototype.fire_ = function() {\n  'use strict';\n  if (this.unhandledErrorId_ && this.hasFired() && this.hasErrback_()) {\n    // It is possible to add errbacks after the Deferred has fired. If a new\n    // errback is added immediately after the Deferred encountered an unhandled\n    // error, but before that error is rethrown, the error is unscheduled.\n    goog.async.Deferred.unscheduleError_(this.unhandledErrorId_);\n    this.unhandledErrorId_ = 0;\n  }\n\n  if (this.parent_) {\n    this.parent_.branches_--;\n    delete this.parent_;\n  }\n\n  let res = this.result_;\n  let unhandledException = false;\n  let isNewlyBlocked = false;\n  let wasConvertedToPromise = false;\n\n  while (this.sequence_.length && !this.blocked_) {\n    wasConvertedToPromise = false;\n    const sequenceEntry = this.sequence_.shift();\n\n    const callback = sequenceEntry[0];\n    const errback = sequenceEntry[1];\n    const scope = sequenceEntry[2];\n\n    const f = this.hadError_ ? errback : callback;\n    if (f) {\n      try {\n        let ret = f.call(scope || this.defaultScope_, res);\n\n        if (ret === goog.async.Deferred.CONVERTED_TO_PROMISE_) {\n          wasConvertedToPromise = true;\n          ret = undefined;\n        }\n\n        // If no result, then use previous result.\n        if (ret !== undefined) {\n          // Bubble up the error as long as the return value hasn't changed.\n          this.hadError_ = this.hadError_ && (ret == res || this.isError(ret));\n          this.result_ = res = ret;\n        }\n\n        if (goog.Thenable.isImplementedBy(res) ||\n            (typeof goog.global['Promise'] === 'function' &&\n            res instanceof goog.global['Promise'])) {\n          isNewlyBlocked = true;\n          this.blocked_ = true;\n        }\n\n      } catch (ex) {\n        res = ex;\n        this.hadError_ = true;\n        this.makeStackTraceLong_(res);\n\n        if (!this.hasErrback_()) {\n          // If an error is thrown with no additional errbacks in the queue,\n          // prepare to rethrow the error.\n          unhandledException = true;\n        }\n      }\n    }\n  }\n\n  this.result_ = res;\n\n  if (isNewlyBlocked) {\n    const onCallback = goog.bind(this.continue_, this, true /* isSuccess */);\n    const onErrback = goog.bind(this.continue_, this, false /* isSuccess */);\n\n    if (res instanceof goog.async.Deferred) {\n      res.addCallbacks(onCallback, onErrback);\n      res.blocking_ = true;\n    } else {\n      /** @type {!IThenable} */ (res).then(onCallback, onErrback);\n    }\n  } else if (\n      goog.async.Deferred.STRICT_ERRORS && !wasConvertedToPromise &&\n      this.isError(res) &&\n      !(res instanceof goog.async.Deferred.CanceledError)) {\n    this.hadError_ = true;\n    unhandledException = true;\n  }\n\n  if (unhandledException) {\n    // Rethrow the unhandled error after a timeout. Execution will continue, but\n    // the error will be seen by global handlers and the user. The throw will\n    // be canceled if another errback is appended before the timeout executes.\n    // The error's original stack trace is preserved where available.\n    this.unhandledErrorId_ = goog.async.Deferred.scheduleError_(res);\n  }\n};\n\n\n/**\n * Creates a Deferred that has an initial result.\n *\n * @param {*=} opt_result The result.\n * @return {!goog.async.Deferred} The new Deferred.\n */\ngoog.async.Deferred.succeed = function(opt_result) {\n  'use strict';\n  const d = new goog.async.Deferred();\n  d.callback(opt_result);\n  return d;\n};\n\n\n/**\n * Creates a Deferred that fires when the given promise resolves.\n * Use only during migration to Promises.\n *\n * Note: If the promise resolves to a thenable value (which is not allowed by\n * conforming promise implementations), then the deferred may behave\n * unexpectedly as it tries to wait on it. This should not be a risk when using\n * goog.Promise, goog.async.Deferred, or native Promise objects.\n *\n * @param {!IThenable<T>} promise\n * @return {!goog.async.Deferred<T>} The new Deferred.\n * @template T\n */\ngoog.async.Deferred.fromPromise = function(promise) {\n  'use strict';\n  const d = new goog.async.Deferred();\n  promise.then(\n      function(value) {\n        'use strict';\n        d.callback(value);\n      },\n      function(error) {\n        'use strict';\n        d.errback(error);\n      });\n  return d;\n};\n\n\n/**\n * Creates a Deferred that has an initial error result.\n *\n * @param {*} res The error result.\n * @return {!goog.async.Deferred} The new Deferred.\n */\ngoog.async.Deferred.fail = function(res) {\n  'use strict';\n  const d = new goog.async.Deferred();\n  d.errback(res);\n  return d;\n};\n\n\n/**\n * Creates a Deferred that has already been canceled.\n *\n * @return {!goog.async.Deferred} The new Deferred.\n */\ngoog.async.Deferred.canceled = function() {\n  'use strict';\n  const d = new goog.async.Deferred();\n  d.cancel();\n  return d;\n};\n\n\n/**\n * Normalizes values that may or may not be Deferreds.\n *\n * If the input value is a Deferred, the Deferred is branched (so the original\n * execution sequence is not modified) and the input callback added to the new\n * branch. The branch is returned to the caller.\n *\n * If the input value is not a Deferred, the callback will be executed\n * immediately and an already firing Deferred will be returned to the caller.\n *\n * In the following (contrived) example, if <code>isImmediate</code> is true\n * then 3 is alerted immediately, otherwise 6 is alerted after a 2-second delay.\n *\n * <pre>\n * var value;\n * if (isImmediate) {\n *   value = 3;\n * } else {\n *   value = new goog.async.Deferred();\n *   setTimeout(function() { value.callback(6); }, 2000);\n * }\n *\n * var d = goog.async.Deferred.when(value, alert);\n * </pre>\n *\n * @param {*} value Deferred or normal value to pass to the callback.\n * @param {function(this:T, ?):?} callback The callback to execute.\n * @param {T=} opt_scope An optional scope to call the callback in.\n * @return {!goog.async.Deferred} A new Deferred that will call the input\n *     callback with the input value.\n * @template T\n */\ngoog.async.Deferred.when = function(value, callback, opt_scope) {\n  'use strict';\n  if (value instanceof goog.async.Deferred) {\n    return value.branch(true).addCallback(callback, opt_scope);\n  } else {\n    return goog.async.Deferred.succeed(value).addCallback(callback, opt_scope);\n  }\n};\n\n\n\n/**\n * An error sub class that is used when a Deferred has already been called.\n * @param {!goog.async.Deferred} deferred The Deferred.\n *\n * @constructor\n * @extends {goog.debug.Error}\n */\ngoog.async.Deferred.AlreadyCalledError = function(deferred) {\n  'use strict';\n  goog.debug.Error.call(this);\n\n  /**\n   * The Deferred that raised this error.\n   * @type {goog.async.Deferred}\n   */\n  this.deferred = deferred;\n};\ngoog.inherits(goog.async.Deferred.AlreadyCalledError, goog.debug.Error);\n\n\n/** @override */\ngoog.async.Deferred.AlreadyCalledError.prototype.message =\n    'Deferred has already fired';\n\n\n/** @override */\ngoog.async.Deferred.AlreadyCalledError.prototype.name = 'AlreadyCalledError';\n\n\n\n/**\n * An error sub class that is used when a Deferred is canceled.\n *\n * @param {!goog.async.Deferred} deferred The Deferred object.\n * @constructor\n * @extends {goog.debug.Error}\n */\ngoog.async.Deferred.CanceledError = function(deferred) {\n  'use strict';\n  goog.debug.Error.call(this);\n\n  /**\n   * The Deferred that raised this error.\n   * @type {goog.async.Deferred}\n   */\n  this.deferred = deferred;\n};\ngoog.inherits(goog.async.Deferred.CanceledError, goog.debug.Error);\n\n\n/** @override */\ngoog.async.Deferred.CanceledError.prototype.message = 'Deferred was canceled';\n\n\n/** @override */\ngoog.async.Deferred.CanceledError.prototype.name = 'CanceledError';\n\n\n\n/**\n * Wrapper around errors that are scheduled to be thrown by failing deferreds\n * after a timeout.\n *\n * @param {*} error Error from a failing deferred.\n * @constructor\n * @final\n * @private\n * @struct\n */\ngoog.async.Deferred.Error_ = function(error) {\n  'use strict';\n  /** @const @private {number} */\n  this.id_ = goog.global.setTimeout(goog.bind(this.throwError, this), 0);\n\n  /** @const @private {*} */\n  this.error_ = error;\n};\n\n\n/**\n * Actually throws the error and removes it from the list of pending\n * deferred errors.\n */\ngoog.async.Deferred.Error_.prototype.throwError = function() {\n  'use strict';\n  goog.asserts.assert(\n      goog.async.Deferred.errorMap_[this.id_],\n      'Cannot throw an error that is not scheduled.');\n  delete goog.async.Deferred.errorMap_[this.id_];\n  goog.async.Deferred.unhandledErrorHandler_(this.error_);\n};\n\n\n/**\n * Resets the error throw timer.\n */\ngoog.async.Deferred.Error_.prototype.resetTimer = function() {\n  'use strict';\n  goog.global.clearTimeout(this.id_);\n};\n\n\n/**\n * Map of unhandled errors scheduled to be rethrown in a future timestep.\n * @private {!Object<(number|string), goog.async.Deferred.Error_>}\n */\ngoog.async.Deferred.errorMap_ = {};\n\n\n/**\n * Schedules an error to be thrown after a delay.\n * @param {*} error Error from a failing deferred.\n * @return {number} Id of the error.\n * @private\n */\ngoog.async.Deferred.scheduleError_ = function(error) {\n  'use strict';\n  const deferredError = new goog.async.Deferred.Error_(error);\n  goog.async.Deferred.errorMap_[deferredError.id_] = deferredError;\n  return deferredError.id_;\n};\n\n\n/**\n * Unschedules an error from being thrown.\n * @param {number} id Id of the deferred error to unschedule.\n * @private\n */\ngoog.async.Deferred.unscheduleError_ = function(id) {\n  'use strict';\n  const error = goog.async.Deferred.errorMap_[id];\n  if (error) {\n    error.resetTimer();\n    delete goog.async.Deferred.errorMap_[id];\n  }\n};\n\n\n/**\n * Asserts that there are no pending deferred errors. If there are any\n * scheduled errors, one will be thrown immediately to make this function fail.\n */\ngoog.async.Deferred.assertNoErrors = function() {\n  'use strict';\n  const map = goog.async.Deferred.errorMap_;\n  for (let key in map) {\n    const error = map[key];\n    error.resetTimer();\n    error.throwError();\n  }\n};\n","^<",1748821315608,"^=",["^3",["~$goog.asserts","^A","~$goog.debug.Error","~$goog.Promise","^C","~$goog.Thenable"]],"^D",["^ ","^E","The Google Closure Library is a collection of JavaScript code\n        designed for use with the Google Closure JavaScript Compiler.\n\n        This non-official distribution was prepared by the ClojureScript\n        team at http://clojure.org/\n\n        This package contains extensions to the Google Closure Library\n        using third-party components, which may be distributed under\n        licenses other than the Apache license. Licenses for individual\n        library components may be found in source-code comments.","^F","^G","^H","^I","^J","Google Closure Library Third-Party Extensions","^K","^L","^M","http://code.google.com/p/closure-library/","^N","^O","^P",["^L","0.0-20250515-f04e4c0e"],"^Q","0.0-20250515-f04e4c0e"],"^R",["^3",["^1?","^1@","^1A","^C","^1B"]],"^S",["^ ","^T",[],"^U",false,"^V",[],"^W",[],"^2",["goog.async.Deferred","goog.async.Deferred.AlreadyCalledError","goog.async.Deferred.CanceledError"],"^X","es6","^Y",null,"^Z",false,"^[",[],"^10",[],"^11",[],"^R",["goog.Promise","goog.Thenable","goog.array","goog.asserts","goog.debug.Error"],"^12",[],"^13",[],"^14",false,"^15",false,"^16",false],"^M",["^17","jar:file:/home/xuelin/.m2/repository/org/clojure/google-closure-library-third-party/0.0-20250515-f04e4c0e/google-closure-library-third-party-0.0-20250515-f04e4c0e.jar!/goog/mochikit/async/deferred.js"],"^18",["^3",["^1<","^1=","^1>"]],"^13",["^3",[]],"^19",true,"^1:",true,"^1;",["^A","^1A","^1B","^C","^1?","^1@"]],["^ ","^1",["c0b576cb976b90eb929938af5e9b6630cd1696f6"],"^2",["^3",["~$goog.async.DeferredList"]],"^5","goog.mochikit.async.deferredlist.js","^6",["^7","goog/mochikit/async/deferredlist.js"],"^8","goog/mochikit/async/deferredlist.js","^9","^:","^;","/**\n * @license\n * Copyright 2005, 2007 Bob Ippolito. All Rights Reserved.\n * Copyright The Closure Library Authors.\n * SPDX-License-Identifier: MIT\n */\n\n// Portions of this code are from MochiKit, received by The Closure\n// Library Authors under the MIT license. All other code is Copyright\n// The Closure Library Authors.\n\n/**\n * @fileoverview Class for tracking multiple asynchronous operations and\n * handling the results. The DeferredList object here is patterned after the\n * DeferredList object in the Twisted python networking framework.\n *\n * Based on the MochiKit code.\n *\n * See: http://twistedmatrix.com/projects/core/documentation/howto/defer.html\n *\n */\n\ngoog.provide('goog.async.DeferredList');\n\ngoog.require('goog.async.Deferred');\n\n\n\n/**\n * Constructs an object that waits on the results of multiple asynchronous\n * operations and marshals the results. It is itself a <code>Deferred</code>,\n * and may have an execution sequence of callback functions added to it. Each\n * <code>DeferredList</code> instance is single use and may be fired only once.\n *\n * The default behavior of a <code>DeferredList</code> is to wait for a success\n * or error result from every <code>Deferred</code> in its input list. Once\n * every result is available, the <code>DeferredList</code>'s execution sequence\n * is fired with a list of <code>[success, result]</code> array pairs, where\n * <code>success</code> is a boolean indicating whether <code>result</code> was\n * the product of a callback or errback. The list's completion criteria and\n * result list may be modified by setting one or more of the boolean options\n * documented below.\n *\n * <code>Deferred</code> instances passed into a <code>DeferredList</code> are\n * independent, and may have additional callbacks and errbacks added to their\n * execution sequences after they are passed as inputs to the list.\n *\n * @param {!Array<!goog.async.Deferred>} list An array of deferred results to\n *     wait for.\n * @param {boolean=} opt_fireOnOneCallback Whether to stop waiting as soon as\n *     one input completes successfully. In this case, the\n *     <code>DeferredList</code>'s callback chain will be called with a two\n *     element array, <code>[index, result]</code>, where <code>index</code>\n *     identifies which input <code>Deferred</code> produced the successful\n *     <code>result</code>.\n * @param {boolean=} opt_fireOnOneErrback Whether to stop waiting as soon as one\n *     input reports an error. The failing result is passed to the\n *     <code>DeferredList</code>'s errback sequence.\n * @param {boolean=} opt_consumeErrors When true, any errors fired by a\n *     <code>Deferred</code> in the input list will be captured and replaced\n *     with a succeeding null result. Any callbacks added to the\n *     <code>Deferred</code> after its use in the <code>DeferredList</code> will\n *     receive null instead of the error.\n * @param {Function=} opt_canceler A function that will be called if the\n *     <code>DeferredList</code> is canceled. @see goog.async.Deferred#cancel\n * @param {Object=} opt_defaultScope The default scope to invoke callbacks or\n *     errbacks in.\n * @constructor\n * @extends {goog.async.Deferred}\n */\ngoog.async.DeferredList = function(\n    list, opt_fireOnOneCallback, opt_fireOnOneErrback, opt_consumeErrors,\n    opt_canceler, opt_defaultScope) {\n  'use strict';\n  goog.async.DeferredList.base(\n      this, 'constructor', opt_canceler, opt_defaultScope);\n\n  /**\n   * The list of Deferred objects to wait for.\n   * @const {!Array<!goog.async.Deferred>}\n   * @private\n   */\n  this.list_ = list;\n\n  /**\n   * The stored return values of the Deferred objects.\n   * @const {!Array}\n   * @private\n   */\n  this.deferredResults_ = [];\n\n  /**\n   * Whether to fire on the first successful callback instead of waiting for\n   * every Deferred to complete.\n   * @const {boolean}\n   * @private\n   */\n  this.fireOnOneCallback_ = !!opt_fireOnOneCallback;\n\n  /**\n   * Whether to fire on the first error result received instead of waiting for\n   * every Deferred to complete.\n   * @const {boolean}\n   * @private\n   */\n  this.fireOnOneErrback_ = !!opt_fireOnOneErrback;\n\n  /**\n   * Whether to stop error propagation on the input Deferred objects. If the\n   * DeferredList sees an error from one of the Deferred inputs, the error will\n   * be captured, and the Deferred will be returned to success state with a null\n   * return value.\n   * @const {boolean}\n   * @private\n   */\n  this.consumeErrors_ = !!opt_consumeErrors;\n\n  /**\n   * The number of input deferred objects that have fired.\n   * @private {number}\n   */\n  this.numFinished_ = 0;\n\n  for (let i = 0; i < list.length; i++) {\n    const d = list[i];\n    d.addCallbacks(goog.bind(this.handleCallback_, this, i, true),\n                   goog.bind(this.handleCallback_, this, i, false));\n  }\n\n  if (list.length == 0 && !this.fireOnOneCallback_) {\n    this.callback(this.deferredResults_);\n  }\n};\ngoog.inherits(goog.async.DeferredList, goog.async.Deferred);\n\n\n/**\n * Registers the result from an input deferred callback or errback. The result\n * is returned and may be passed to additional handlers in the callback chain.\n *\n * @param {number} index The index of the firing deferred object in the input\n *     list.\n * @param {boolean} success Whether the result is from a callback or errback.\n * @param {*} result The result of the callback or errback.\n * @return {*} The result, to be handled by the next handler in the deferred's\n *     callback chain (if any). If consumeErrors is set, an error result is\n *     replaced with null.\n * @private\n */\ngoog.async.DeferredList.prototype.handleCallback_ = function(\n    index, success, result) {\n  'use strict';\n  this.numFinished_++;\n  this.deferredResults_[index] = [success, result];\n\n  if (!this.hasFired()) {\n    if (this.fireOnOneCallback_ && success) {\n      this.callback([index, result]);\n    } else if (this.fireOnOneErrback_ && !success) {\n      this.errback(result);\n    } else if (this.numFinished_ == this.list_.length) {\n      this.callback(this.deferredResults_);\n    }\n  }\n\n  if (this.consumeErrors_ && !success) {\n    result = null;\n  }\n\n  return result;\n};\n\n\n/** @override */\ngoog.async.DeferredList.prototype.errback = function(res) {\n  'use strict';\n  goog.async.DeferredList.base(this, 'errback', res);\n\n  // On error, cancel any pending requests.\n  for (let i = 0; i < this.list_.length; i++) {\n    this.list_[i].cancel();\n  }\n};\n\n\n/**\n * Creates a <code>DeferredList</code> that gathers results from multiple\n * <code>Deferred</code> inputs. If all inputs succeed, the callback is fired\n * with the list of results as a flat array. If any input fails, the list's\n * errback is fired immediately with the offending error, and all other pending\n * inputs are canceled.\n *\n * @param {!Array<!goog.async.Deferred>} list The list of <code>Deferred</code>\n *     inputs to wait for.\n * @return {!goog.async.Deferred} The deferred list of results from the inputs\n *     if they all succeed, or the error result of the first input to fail.\n */\ngoog.async.DeferredList.gatherResults = function(list) {\n  'use strict';\n  return new goog.async.DeferredList(list, false, true)\n      .addCallback(function(results) {\n        'use strict';\n        const output = [];\n        for (let i = 0; i < results.length; i++) {\n          output[i] = results[i][1];\n        }\n        return output;\n      });\n};\n","^<",1748821315608,"^=",["^3",["^A","^1="]],"^D",["^ ","^E","The Google Closure Library is a collection of JavaScript code\n        designed for use with the Google Closure JavaScript Compiler.\n\n        This non-official distribution was prepared by the ClojureScript\n        team at http://clojure.org/\n\n        This package contains extensions to the Google Closure Library\n        using third-party components, which may be distributed under\n        licenses other than the Apache license. Licenses for individual\n        library components may be found in source-code comments.","^F","^G","^H","^I","^J","Google Closure Library Third-Party Extensions","^K","^L","^M","http://code.google.com/p/closure-library/","^N","^O","^P",["^L","0.0-20250515-f04e4c0e"],"^Q","0.0-20250515-f04e4c0e"],"^R",["^3",["^1="]],"^S",["^ ","^T",[],"^U",false,"^V",[],"^W",[],"^2",["goog.async.DeferredList"],"^X","es6","^Y",null,"^Z",false,"^[",[],"^10",[],"^11",[],"^R",["goog.async.Deferred"],"^12",[],"^13",[],"^14",false,"^15",false,"^16",false],"^M",["^17","jar:file:/home/xuelin/.m2/repository/org/clojure/google-closure-library-third-party/0.0-20250515-f04e4c0e/google-closure-library-third-party-0.0-20250515-f04e4c0e.jar!/goog/mochikit/async/deferredlist.js"],"^18",["^3",["^1C"]],"^13",["^3",[]],"^19",true,"^1:",true,"^1;",["^A","^1="]]],"~:shadow.build.classpath/CACHE-TIMESTAMP",1748825430000]